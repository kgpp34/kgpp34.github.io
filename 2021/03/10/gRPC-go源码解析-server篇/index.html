<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="有关gRPC是什么和其特性这里不详细展开，相关的文章特别多，自行搜索即可，这里直接开始对官方示例hello world项目源码的阅读。 从hello-world例子中的server&#x2F;main.go中我们看到生成一个server的代码段如下： 123456789lis, err :&#x3D; net.Listen(&quot;tcp&quot;, port)if err !&#x3D; nil &amp;#123;	log.">
<meta property="og:type" content="article">
<meta property="og:title" content="gRPC-go源码解析-server篇">
<meta property="og:url" content="http://example.com/2021/03/10/gRPC-go%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-server%E7%AF%87/index.html">
<meta property="og:site_name" content="多模型自适应混子的技术老巢">
<meta property="og:description" content="有关gRPC是什么和其特性这里不详细展开，相关的文章特别多，自行搜索即可，这里直接开始对官方示例hello world项目源码的阅读。 从hello-world例子中的server&#x2F;main.go中我们看到生成一个server的代码段如下： 123456789lis, err :&#x3D; net.Listen(&quot;tcp&quot;, port)if err !&#x3D; nil &amp;#123;	log.">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-03-10T11:48:26.000Z">
<meta property="article:modified_time" content="2021-03-10T11:50:16.686Z">
<meta property="article:author" content="Larry Young">
<meta property="article:tag" content="gRPC">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2021/03/10/gRPC-go%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-server%E7%AF%87/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>gRPC-go源码解析-server篇 | 多模型自适应混子的技术老巢</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">多模型自适应混子的技术老巢</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">我就没见过比我科研还水的研究生</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/10/gRPC-go%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-server%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Larry Young">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="多模型自适应混子的技术老巢">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          gRPC-go源码解析-server篇
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-03-10 19:48:26 / Modified: 19:50:16" itemprop="dateCreated datePublished" datetime="2021-03-10T19:48:26+08:00">2021-03-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>有关gRPC是什么和其特性这里不详细展开，相关的文章特别多，自行搜索即可，这里直接开始对官方示例<code>hello world</code>项目源码的阅读。</p>
<p>从<code>hello-world</code>例子中的<code>server/main.go</code>中我们看到生成一个<code>server</code>的代码段如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, port)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Fatalf(<span class="string">&quot;failed to listen: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">s := grpc.NewServer()</span><br><span class="line">pb.RegisterGreeterServer(s, &amp;server&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err := s.Serve(lis); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Fatalf(<span class="string">&quot;failed to serve: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这段代码逻辑可以看出创建一个server大致分为如下几步：</p>
<ul>
<li>创建一个新的<code>server(grpc.NewServer())</code></li>
<li><code>server</code>进行注册</li>
<li>调用方法监听端口</li>
</ul>
<h4 id="创建server"><a href="#创建server" class="headerlink" title="创建server"></a>创建server</h4><p>在这段逻辑里我们通过进入<code>NewServer</code>方法，可以看到如下代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(opt ...ServerOption)</span> *<span class="title">Server</span></span> &#123;</span><br><span class="line">	opts := defaultServerOptions <span class="comment">// 1.</span></span><br><span class="line">	<span class="keyword">for</span> _, o := <span class="keyword">range</span> opt &#123;</span><br><span class="line">		o.apply(&amp;opts)</span><br><span class="line">	&#125;</span><br><span class="line">	s := &amp;Server&#123; <span class="comment">// 2.</span></span><br><span class="line">		lis:    <span class="built_in">make</span>(<span class="keyword">map</span>[net.Listener]<span class="keyword">bool</span>),</span><br><span class="line">		opts:   opts,</span><br><span class="line">		conns:  <span class="built_in">make</span>(<span class="keyword">map</span>[transport.ServerTransport]<span class="keyword">bool</span>),</span><br><span class="line">		m:      <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*service),</span><br><span class="line">		quit:   grpcsync.NewEvent(),</span><br><span class="line">		done:   grpcsync.NewEvent(),</span><br><span class="line">		czData: <span class="built_in">new</span>(channelzData),</span><br><span class="line">	&#125;</span><br><span class="line">	chainUnaryServerInterceptors(s) <span class="comment">// 3.</span></span><br><span class="line">	chainStreamServerInterceptors(s)</span><br><span class="line">	s.cv = sync.NewCond(&amp;s.mu)</span><br><span class="line">	<span class="keyword">if</span> EnableTracing &#123;</span><br><span class="line">		_, file, line, _ := runtime.Caller(<span class="number">1</span>)</span><br><span class="line">		s.events = trace.NewEventLog(<span class="string">&quot;grpc.Server&quot;</span>, fmt.Sprintf(<span class="string">&quot;%s:%d&quot;</span>, file, line))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> channelz.IsOn() &#123;</span><br><span class="line">		s.channelzID = channelz.RegisterServer(&amp;channelzServer&#123;s&#125;, <span class="string">&quot;&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们逐行进行分析，首先该方法的入参是一些服务器的可选参数，<code>ServerOption</code>本身是一个接口，里面有一个<code>apply</code>方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ServerOption <span class="keyword">interface</span> &#123;</span><br><span class="line">    apply(*serverOptions)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据官方给出的注释，我们可以看到这个接口里的方法主要是对server设置一些可选参数，比如codec，或者是参数的生命周期等。而<code>serverOptions</code>这个结构体也恰恰定义的是这些服务器的参数。</p>
<p>回到注释1的位置，那么首先我们的程序就是设置了必要的服务器参数，具体的内容如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> defaultServerOptions = serverOptions&#123;</span><br><span class="line">	maxReceiveMessageSize: defaultServerMaxReceiveMessageSize,</span><br><span class="line">	maxSendMessageSize:    defaultServerMaxSendMessageSize,</span><br><span class="line">	connectionTimeout:     <span class="number">120</span> * time.Second,</span><br><span class="line">	writeBufferSize:       defaultWriteBufSize,</span><br><span class="line">	readBufferSize:        defaultReadBufSize,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如说默认的最大可接收和发送的消息大小，连接的超时时间和Buffer的大小。</p>
<p>然后进入的for循环就是将服务器参数都设置到我们的<code>optionServers</code>这个结构体中。</p>
<p>再向下走进入到注释2的位置，就是对我们的Server结构体做了设置，Server的结构如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">    opts serverOptions</span><br><span class="line"></span><br><span class="line">    mu     sync.Mutex <span class="comment">// 互斥锁</span></span><br><span class="line">    lis    <span class="keyword">map</span>[net.Listener]<span class="keyword">bool</span> <span class="comment">// listener map</span></span><br><span class="line">    conns  <span class="keyword">map</span>[transport.ServerTransport]<span class="keyword">bool</span> <span class="comment">//connextions map</span></span><br><span class="line">    serve  <span class="keyword">bool</span> <span class="comment">// 是否在处理请求的状态位</span></span><br><span class="line">    drain  <span class="keyword">bool</span></span><br><span class="line">    cv     *sync.Cond          <span class="comment">// signaled when connections close for GracefulStop</span></span><br><span class="line">    m      <span class="keyword">map</span>[<span class="keyword">string</span>]*service <span class="comment">// service name -&gt; service info</span></span><br><span class="line">    events trace.EventLog</span><br><span class="line"></span><br><span class="line">    quit               *grpcsync.Event</span><br><span class="line">    done               *grpcsync.Event</span><br><span class="line">    channelzRemoveOnce sync.Once</span><br><span class="line">    serveWG            sync.WaitGroup <span class="comment">// counts active Serve goroutines for GracefulStop</span></span><br><span class="line"></span><br><span class="line">    channelzID <span class="keyword">int64</span> <span class="comment">// channelz unique identification number</span></span><br><span class="line">    czData     *channelzData</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里面比较重要的有3个map，分别存储的是listener的信息，connection的信息以及提供的service的信息。而其他的字段主要是提供了某些服务器的状态信息或者并发控制的功能。</p>
<p>那么首先对于存储listener的map而言，listener本质是一个接口，里面提供了<code>Accept()</code>,<code>Close()</code>,<code>Addr()</code>三个方法，分别提供是服务器准备进行连接，和关闭listener，以及返回listener网络地址的功能。</p>
<p>对存储service的map而言，service的结构如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> service <span class="keyword">struct</span> &#123;</span><br><span class="line">    server <span class="keyword">interface</span>&#123;&#125; <span class="comment">// the server for service methods</span></span><br><span class="line">    md     <span class="keyword">map</span>[<span class="keyword">string</span>]*MethodDesc</span><br><span class="line">    sd     <span class="keyword">map</span>[<span class="keyword">string</span>]*StreamDesc</span><br><span class="line">    mdata  <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>server接口里存放的是该服务器所提供的service方法，而下面两个map则是存储了method和stream流的服务信息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MethodDesc <span class="keyword">struct</span> &#123;</span><br><span class="line">    MethodName <span class="keyword">string</span></span><br><span class="line">    Handler    methodHandler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> StreamDesc <span class="keyword">struct</span> &#123;</span><br><span class="line">    StreamName <span class="keyword">string</span></span><br><span class="line">    Handler    StreamHandler</span><br><span class="line"></span><br><span class="line">    <span class="comment">// At least one of these is true.</span></span><br><span class="line">    ServerStreams <span class="keyword">bool</span></span><br><span class="line">    ClientStreams <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中每一个struct里面都有一个handler来对调用的方法进行处理。</p>
<p>回到主流程的注释3的位置，可以看到有两个拦截器，第一个拦截器主要是将我们定义的server端的拦截器最终都用一个拦截器链进行规整：(具体内容见注释)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chainUnaryServerInterceptors</span><span class="params">(s *Server)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Prepend opts.unaryInt to the chaining interceptors if it exists, since unaryInt will</span></span><br><span class="line">	<span class="comment">// be executed before any other chained interceptors.</span></span><br><span class="line">    <span class="comment">// 这几步主要是检查一下拦截器的个数，如果方法unary拦截器数组不是空的话，就要把这些拦截器继续添加到我们的拦截器链上</span></span><br><span class="line">	interceptors := s.opts.chainUnaryInts <span class="comment">// </span></span><br><span class="line">	<span class="keyword">if</span> s.opts.unaryInt != <span class="literal">nil</span> &#123;</span><br><span class="line">		interceptors = <span class="built_in">append</span>([]UnaryServerInterceptor&#123;s.opts.unaryInt&#125;, s.opts.chainUnaryInts...)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> chainedInt UnaryServerInterceptor</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(interceptors) == <span class="number">0</span> &#123;</span><br><span class="line">		chainedInt = <span class="literal">nil</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(interceptors) == <span class="number">1</span> &#123;</span><br><span class="line">		chainedInt = interceptors[<span class="number">0</span>]</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		chainedInt = <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;, info *UnaryServerInfo, handler UnaryHandler)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">            <span class="comment">// 如果拦截器数量大于1，那么会递归的生成一个拦截器链</span></span><br><span class="line">			<span class="keyword">return</span> interceptors[<span class="number">0</span>](ctx, req, info, getChainUnaryHandler(interceptors, <span class="number">0</span>, info, handler))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s.opts.unaryInt = chainedInt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<code>getChainUnaryHandler</code>方法的逻辑需要看一下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getChainUnaryHandler</span><span class="params">(interceptors []UnaryServerInterceptor, curr <span class="keyword">int</span>, info *UnaryServerInfo, finalHandler UnaryHandler)</span> <span class="title">UnaryHandler</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> curr == <span class="built_in">len</span>(interceptors)<span class="number">-1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> finalHandler</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> interceptors[curr+<span class="number">1</span>](ctx, req, info, getChainUnaryHandler(interceptors, curr+<span class="number">1</span>, info, finalHandler))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在本段逻辑里，首先判断当前的curr指针是不是整个拦截器链的末尾，如果是的话就会返回最尾端的handler，否则就不断的递归，从而生成一条拦截器链。</p>
<p><code>chainStreamServerInterceptors</code>和<code>chainUnaryServerInterceptors</code>方法类似，这里不再赘述。</p>
<h4 id="server注册"><a href="#server注册" class="headerlink" title="server注册"></a>server注册</h4><p>继续回到主线，在完成了相应的server设置之后，就要对server进行注册，跟随</p>
<p><code>  pb.RegisterGreeterServer(s, &amp;server&#123;&#125;)</code>方法一路进入到<code>RegisterService</code>方法，即：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">RegisterService</span><span class="params">(sd *ServiceDesc, ss <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	ht := reflect.TypeOf(sd.HandlerType).Elem()</span><br><span class="line">	st := reflect.TypeOf(ss)</span><br><span class="line">	<span class="keyword">if</span> !st.Implements(ht) &#123;</span><br><span class="line">		grpclog.Fatalf(<span class="string">&quot;grpc: Server.RegisterService found the handler of type %v that does not satisfy %v&quot;</span>, st, ht)</span><br><span class="line">	&#125;</span><br><span class="line">	s.register(sd, ss)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先就是通过反射来获取server当中handler链中每个handler的类型，再获自己定义的service的类型，紧接着就是判断一下是否自定义的service的类型实现了我们要求的server里面handler的类型，如果是的话就进入<code>register</code>的逻辑。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">register</span><span class="params">(sd *ServiceDesc, ss <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	s.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> s.mu.Unlock()</span><br><span class="line">	s.printf(<span class="string">&quot;RegisterService(%q)&quot;</span>, sd.ServiceName)</span><br><span class="line">	<span class="keyword">if</span> s.serve &#123;</span><br><span class="line">		grpclog.Fatalf(<span class="string">&quot;grpc: Server.RegisterService after Server.Serve for %q&quot;</span>, sd.ServiceName)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> _, ok := s.m[sd.ServiceName]; ok &#123;</span><br><span class="line">		grpclog.Fatalf(<span class="string">&quot;grpc: Server.RegisterService found duplicate service registration for %q&quot;</span>, sd.ServiceName)</span><br><span class="line">	&#125;</span><br><span class="line">	srv := &amp;service&#123;</span><br><span class="line">		server: ss,</span><br><span class="line">		md:     <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*MethodDesc),</span><br><span class="line">		sd:     <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*StreamDesc),</span><br><span class="line">		mdata:  sd.Metadata,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> sd.Methods &#123;</span><br><span class="line">		d := &amp;sd.Methods[i]</span><br><span class="line">		srv.md[d.MethodName] = d</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> sd.Streams &#123;</span><br><span class="line">		d := &amp;sd.Streams[i]</span><br><span class="line">		srv.sd[d.StreamName] = d</span><br><span class="line">	&#125;</span><br><span class="line">	s.m[sd.ServiceName] = srv</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先在这段逻辑里最开始判断了下是不是先注册了方法后启动的server，和是不是重复注册了service，如果都没有的话，则按照方法名为 key，将方法注入到 server 的 service map 中。看到这里我们其实可以预测一下，server 不同 rpc 请求的处理，也是根据 service 中不同的 serviceName 去 service map 中取出不同的 handler 进行处理。</p>
<h4 id="启动Serve"><a href="#启动Serve" class="headerlink" title="启动Serve"></a>启动Serve</h4><p>对于通常的C/S架构的通信，普遍的实现都是server端不断地嗅探本端口是不是有连接请求，如果有client端进行连接，那么就握手建立连接，然后client通过调用相应的方法和参数对server的service进行调用，这个请求就对打到server端的handler处来进行处理。所以，对 server 端来说，主要是了解其如何实现监听，如何为请求分配不同的 handler 和 回写响应数据。来看一下具体的<code>Serve</code>方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">Serve</span><span class="params">(lis net.Listener)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	s.mu.Lock()</span><br><span class="line">	s.printf(<span class="string">&quot;serving&quot;</span>)</span><br><span class="line">	s.serve = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">if</span> s.lis == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Serve called after Stop or GracefulStop.</span></span><br><span class="line">		s.mu.Unlock()</span><br><span class="line">		lis.Close()</span><br><span class="line">		<span class="keyword">return</span> ErrServerStopped</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s.serveWG.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		s.serveWG.Done()</span><br><span class="line">		<span class="keyword">if</span> s.quit.HasFired() &#123;</span><br><span class="line">			<span class="comment">// Stop or GracefulStop called; block until done and return nil.</span></span><br><span class="line">			&lt;-s.done.Done()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	ls := &amp;listenSocket&#123;Listener: lis&#125;</span><br><span class="line">	s.lis[ls] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> channelz.IsOn() &#123;</span><br><span class="line">		ls.channelzID = channelz.RegisterListenSocket(ls, s.channelzID, lis.Addr().String())</span><br><span class="line">	&#125;</span><br><span class="line">	s.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		s.mu.Lock()</span><br><span class="line">		<span class="keyword">if</span> s.lis != <span class="literal">nil</span> &amp;&amp; s.lis[ls] &#123;</span><br><span class="line">			ls.Close()</span><br><span class="line">			<span class="built_in">delete</span>(s.lis, ls)</span><br><span class="line">		&#125;</span><br><span class="line">		s.mu.Unlock()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> tempDelay time.Duration <span class="comment">// how long to sleep on accept failure</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		rawConn, err := lis.Accept() <span class="comment">// 4</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> ne, ok := err.(<span class="keyword">interface</span> &#123;</span><br><span class="line">				Temporary() <span class="keyword">bool</span></span><br><span class="line">			&#125;); ok &amp;&amp; ne.Temporary() &#123;</span><br><span class="line">				<span class="keyword">if</span> tempDelay == <span class="number">0</span> &#123;</span><br><span class="line">					tempDelay = <span class="number">5</span> * time.Millisecond</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					tempDelay *= <span class="number">2</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> max := <span class="number">1</span> * time.Second; tempDelay &gt; max &#123;</span><br><span class="line">					tempDelay = max</span><br><span class="line">				&#125;</span><br><span class="line">				s.mu.Lock()</span><br><span class="line">				s.printf(<span class="string">&quot;Accept error: %v; retrying in %v&quot;</span>, err, tempDelay)</span><br><span class="line">				s.mu.Unlock()</span><br><span class="line">				timer := time.NewTimer(tempDelay)</span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> &lt;-timer.C:</span><br><span class="line">				<span class="keyword">case</span> &lt;-s.quit.Done():</span><br><span class="line">					timer.Stop()</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			s.mu.Lock()</span><br><span class="line">			s.printf(<span class="string">&quot;done serving; Accept = %v&quot;</span>, err)</span><br><span class="line">			s.mu.Unlock()</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> s.quit.HasFired() &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		tempDelay = <span class="number">0</span></span><br><span class="line">		<span class="comment">// Start a new goroutine to deal with rawConn so we don&#x27;t stall this Accept</span></span><br><span class="line">		<span class="comment">// loop goroutine.</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// Make sure we account for the goroutine so GracefulStop doesn&#x27;t nil out</span></span><br><span class="line">		<span class="comment">// s.conns before this conn can be added.</span></span><br><span class="line">		s.serveWG.Add(<span class="number">1</span>) <span class="comment">// 5.</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			s.handleRawConn(rawConn)</span><br><span class="line">			s.serveWG.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从注释4开始，我们看到程序进入循环然后监听对应的端口。紧接在看到注释5我们发现程序起了一个goroutine去调用<code>handleRawConn</code>方法，进一步跟踪进去：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">handleRawConn</span><span class="params">(rawConn net.Conn)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    conn, authInfo, err := s.useTransportAuthenticator(rawConn)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// Finish handshaking (HTTP2)</span></span><br><span class="line">    st := s.newHTTP2Transport(conn, authInfo)</span><br><span class="line">    <span class="keyword">if</span> st == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        s.serveStreams(st)</span><br><span class="line">        s.removeConn(st)</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我将不重要的地方进行了省略，可以看到在本方法内，确实是通过建立HTTP2的握手来实现了连接的建立，然后程序又开了一个goroutine来调用了<code>serveStreams</code>方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">serveStreams</span><span class="params">(st transport.ServerTransport)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> st.Close()</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    st.HandleStreams(<span class="function"><span class="keyword">func</span><span class="params">(stream *transport.Stream)</span></span> &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            s.handleStream(st, stream, s.traceInfo(st, stream))</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, method <span class="keyword">string</span>)</span> <span class="title">context</span>.<span class="title">Context</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !EnableTracing &#123;</span><br><span class="line">            <span class="keyword">return</span> ctx</span><br><span class="line">        &#125;</span><br><span class="line">        tr := trace.New(<span class="string">&quot;grpc.Recv.&quot;</span>+methodFamily(method), method)</span><br><span class="line">        <span class="keyword">return</span> trace.NewContext(ctx, tr)</span><br><span class="line">    &#125;)</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里依然是调用了<code>handleStreams</code>方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">handleStream</span><span class="params">(t transport.ServerTransport, stream *transport.Stream, trInfo *traceInfo)</span></span> &#123;</span><br><span class="line">    sm := stream.Method()</span><br><span class="line">    ...</span><br><span class="line">    service := sm[:pos]</span><br><span class="line">    method := sm[pos+<span class="number">1</span>:]</span><br><span class="line">    srv, knownService := s.m[service]</span><br><span class="line">    <span class="keyword">if</span> knownService &#123;</span><br><span class="line">        <span class="keyword">if</span> md, ok := srv.md[method]; ok &#123;</span><br><span class="line">            s.processUnaryRPC(t, stream, srv, md, trInfo)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> sd, ok := srv.sd[method]; ok &#123;</span><br><span class="line">            s.processStreamingRPC(t, stream, srv, sd, trInfo)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，果然，程序根据 serviceName 去 server 中的 service map，也就是 m 这个字段里去取出 handler 进行处理。我们 hello world 这个 demo 的请求不涉及到 stream ，所以直接取出 handler ，然后传给 processUnaryRPC 这个方法进行处理。</p>
<p>所以我们进一步跟进<code>processUnaryRPC</code>方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">processUnaryRPC</span><span class="params">(t transport.ServerTransport, stream *transport.Stream, srv *service, md *MethodDesc, trInfo *traceInfo)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    sh := s.opts.statsHandler</span><br><span class="line">    <span class="keyword">if</span> sh != <span class="literal">nil</span> &#123;</span><br><span class="line">        beginTime := time.Now()</span><br><span class="line">        begin := &amp;stats.Begin&#123;</span><br><span class="line">            BeginTime: beginTime,</span><br><span class="line">        &#125;</span><br><span class="line">        sh.HandleRPC(stream.Context(), begin)</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            end := &amp;stats.End&#123;</span><br><span class="line">                BeginTime: beginTime,</span><br><span class="line">                EndTime:   time.Now(),</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err != io.EOF &#123;</span><br><span class="line">                end.Error = toRPCErr(err)</span><br><span class="line">            &#125;</span><br><span class="line">            sh.HandleRPC(stream.Context(), end)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> err := s.sendResponse(t, stream, reply, cp, opts, comp); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">            <span class="comment">// The entire stream is done (for unary RPC only).</span></span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> s, ok := status.FromError(err); ok &#123;</span><br><span class="line">            <span class="keyword">if</span> e := t.WriteStatus(stream, s); e != <span class="literal">nil</span> &#123;</span><br><span class="line">                grpclog.Warningf(<span class="string">&quot;grpc: Server.processUnaryRPC failed to write status: %v&quot;</span>, e)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> st := err.(<span class="keyword">type</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span> transport.ConnectionError:</span><br><span class="line">                <span class="comment">// Nothing to do here.</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;grpc: Unexpected error (%T) from sendResponse: %v&quot;</span>, st, st))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> binlog != <span class="literal">nil</span> &#123;</span><br><span class="line">            h, _ := stream.Header()</span><br><span class="line">            binlog.Log(&amp;binarylog.ServerHeader&#123;</span><br><span class="line">                Header: h,</span><br><span class="line">            &#125;)</span><br><span class="line">            binlog.Log(&amp;binarylog.ServerTrailer&#123;</span><br><span class="line">                Trailer: stream.Trailer(),</span><br><span class="line">                Err:     appErr,</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现了对handler方法的调用和response的回写。</p>
<p>那么gRPC server端部分源码到这里就结束了，有关其他的stream方式放到以后的文章进行阅读。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/gRPC/" rel="tag"># gRPC</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/01/31/HTTP%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" rel="prev" title="HTTP长连接实现原理">
      <i class="fa fa-chevron-left"></i> HTTP长连接实现原理
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BAserver"><span class="nav-number">1.</span> <span class="nav-text">创建server</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#server%E6%B3%A8%E5%86%8C"><span class="nav-number">2.</span> <span class="nav-text">server注册</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8Serve"><span class="nav-number">3.</span> <span class="nav-text">启动Serve</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Larry Young</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Larry Young</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
