<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>多模型自适应混子的技术老巢</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="多模型自适应混子的技术老巢">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="多模型自适应混子的技术老巢">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Larry Young">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="多模型自适应混子的技术老巢" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">多模型自适应混子的技术老巢</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-ElasticSearch基本概念与原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/24/ElasticSearch%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%8E%9F%E7%90%86/" class="article-date">
  <time datetime="2020-11-24T15:28:29.000Z" itemprop="datePublished">2020-11-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/24/ElasticSearch%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%8E%9F%E7%90%86/">ElasticSearch基本概念与原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="ElasticSearch基本介绍"><a href="#ElasticSearch基本介绍" class="headerlink" title="ElasticSearch基本介绍"></a>ElasticSearch基本介绍</h2><ul>
<li><p>ES是什么？</p>
<p>ES是一款基于Apache Lucene的开源分布式搜索引擎</p>
</li>
<li><p>应用场景</p>
<ul>
<li>日志记录与分析（接口调用情况）</li>
<li>采集和组合公共数据（用户行为、点击事件）</li>
<li>全文检索</li>
<li>数据可视化（通过Kibana）</li>
</ul>
</li>
<li><p>逻辑与物理设计</p>
<p>首先看一些概念：</p>
<ul>
<li><p>集群cluster</p>
<p>ES是分布式的，多个节点构成一个集群，并且集群也是可扩展的</p>
</li>
<li><p>节点node</p>
<p>每个启动的ES实例就是一个节点，可以随时加入或者脱离集群</p>
</li>
<li><p>索引index</p>
<p>名词：一堆字段相似的文档的集合，类比MySQL的一张表</p>
<p>动词：将文档写入某个索引</p>
</li>
<li><p>文档document</p>
<p>一条ES的记录，类比MySQL的一行数据</p>
</li>
<li><p>分片shard</p>
<ul>
<li>分片是ES所能管理的最小单元</li>
<li>一个分片就是一个Lucenne索引</li>
<li>一个包含倒排索引的文件目录</li>
<li>分片越多（过度分片），搜索有可能越慢</li>
</ul>
</li>
<li><p>分段segment</p>
<ul>
<li><p>lucene索引再分割的小单元</p>
</li>
<li><p>分段不会被修改</p>
</li>
<li><p>分段越多，搜索越慢</p>
</li>
<li><p>索引新的文档会创建新的分段</p>
</li>
<li><p>分段会被持续地合并</p>
</li>
<li><p>删除文档的时候不会真的删除（只是设置了标记）</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>分片：扩展与容灾</p>
</blockquote>
<p><img src="/.com//%E7%B4%A2%E5%BC%95%E8%AF%B7%E6%B1%82.jpg"></p>
<p>首先，一个索引地所有分片会自动均匀地分布在所有节点中。当我们加入一个新节点后，如下图所示，原集群节点中地分片，有部分会迁移到新节点。</p>
<p><img src="/.com//%E5%8A%A0%E5%85%A5%E8%8A%82%E7%82%B9.jpg"></p>
<p><em>注：设置分片数量稍微大于节点数量，有利于横向扩容时，分片蔓延到所有新节点，如图一所示，就是一个index包含四个分片，而es集群中有三个节点，新加入节点后可以蔓延（最理想的状态就是每个节点都有分片）。但是蔓延的过程是有一定消耗的，所以会对集群产生一些抖动的。此外，当主分片和所有副本分片都就绪时，索引地健康状态是绿色</em></p>
<p>我们在Kibana的monitoring组件上可以看见分片的活跃程度。</p>
<p>接下来我们来分析容灾，如下图所示为在图1的基础上挂掉一个节点的示意图。</p>
<p><img src="/.com//%E6%8C%82%E6%8E%89%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9.jpg"></p>
<ul>
<li>当挂掉了N个节点时，如果副本分片是N，那么剩下的副本分片将  自动提升为主分片。</li>
<li>然后所有的主分片能构成完整的索引，但是副本分片缺失时，此时索引健康状态是黄色。</li>
<li>如果挂掉N+1个节点，主分片将缺失，健康状态是红色。</li>
<li>我们需要根据实际情况合理的设置副本的数量（副本太多也会影响性能）</li>
<li>通常同时挂掉两个节点的概率不高，一般来说一个副本可以满足常规容灾要求。</li>
</ul>
<blockquote>
<p>索引和搜索数据</p>
</blockquote>
<p>索引请求如下图所示：</p>
<p><img src="/.com//%E7%B4%A2%E5%BC%95%E8%AF%B7%E6%B1%82.jpg"></p>
<ul>
<li><p>具体过程</p>
<ul>
<li>索引文档请求到一个节点</li>
<li>文档会被随机到一个主分片上</li>
<li>从主分片同步到副本分片</li>
<li>返回成功的结果</li>
</ul>
<p>注：副本分片越多，索引数据越慢，因为要所有副本都完成才算成功</p>
</li>
</ul>
<p>再来看搜索过程，如下图所示：</p>
<p><img src="/.com//%E6%90%9C%E7%B4%A2%E8%AF%B7%E6%B1%82.jpg"></p>
<ul>
<li><p>具体过程</p>
<ul>
<li>搜索请求到一个节点</li>
<li>节点转发请求到本节点的一个分片和其他节点的另一个分片</li>
<li>所有的分片都返回搜索结果到起始节点，但是只要有一个shard搜索到了数据就会立刻返回</li>
<li>起始节点返回搜索结果到请求方</li>
</ul>
<p>注：不同节点的主分片+副本分片的总数越多，请求被分摊的越  多，并发搜索兴能越好。但是如果节点数很少，分片都集中到了少数节点上，搜索速度会变慢，因为增加了开销，实际没有分摊负载。此外，单个搜索没有办法通过分片加速。</p>
</li>
</ul>
<blockquote>
<p>分段</p>
</blockquote>
<p><img src="/.com//%E5%88%86%E6%AE%B5.jpg"></p>
<ul>
<li><p>写入</p>
<ul>
<li>只能写打开的分段（为了避免冲入合并）</li>
<li>删除是假的删除，也是往打开的分段里写标志位（这是为了保证随机读写）</li>
<li>分段大小超过一定阈值，会触发分段合并</li>
<li>小分段合并成大分段，为了查询加速，但合并过程是先创建一个大分段，再把两个小的放进去，再删除这两个小的，但这个过程会耗费大量资源</li>
<li>如果希望写入快，就要避免频繁的分段合并</li>
</ul>
</li>
<li><p>读取</p>
<ul>
<li>只能读取关闭的分段（所以ES叫准实时，关闭这个过程也叫做刷新）</li>
<li>对一个分片查询，会等它所有的分段返回结果，所以分段过多，查询越慢</li>
<li>刷新时，会关闭一批分段，这时候数据才能被查到</li>
<li>刷新频率太快会导致分段碎片多</li>
<li>刷新频率过慢会导致实时性低</li>
</ul>
</li>
</ul>
<p><em>总结一下，我们可以看到，如果我们追求的是写入更快的话，我们就要尽力的避免频繁的分段合并，保留相对多一点的分段；但是如果我们要追求读取性能的话又要考虑减少分段，这也就是鱼和熊掌的问题了，需要我们结合实际业务场景进行分析。</em></p>
<p>Kibana中的一些设置：</p>
<p><img src="/.com//kibana%E8%AE%BE%E7%BD%AE.jpg"></p>
<p>在Kibana中我们可以设置刷新的频率、副本数量等等参数</p>
<ul>
<li><p>那么索引分片不是免费的吗/分片越多越好吗？</p>
<ul>
<li><p>每个索引和分片都会产生一定的资源开销，尤其是内存资源</p>
</li>
<li><p>每个索引，映射和状态的信息都存储在集群中</p>
<ul>
<li>存储在内存中，以便快速访问</li>
<li>分片数量过多，会导致集群状态过大</li>
<li>这会导致更新变慢，因为所有的更新都是通过单线程来完成的，从而这是在将变更分发到整个集群之前确保一致性的前提</li>
</ul>
</li>
<li><p>分片有一部分数据需要保存在内存中</p>
<ul>
<li>这部分数据也会占据堆内存空间</li>
<li>这包括存储分片级别以及段级别信息的数据结构</li>
<li>因为只有这样才能确定数据在磁盘上的存储位置</li>
</ul>
</li>
<li><p>那怎么样在单个节点上存储尽可能多的数据呢？</p>
<ul>
<li>管理堆内存使用量</li>
<li>尽可能减少开销</li>
<li>节点的堆内存空间越多，能处理的数据和分片就越多</li>
<li>官方建议：JVM heap每1G不超过20个分片，每个分片大小在20G</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<p><em>参考连接</em></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1kf4y1R7qR">https://www.bilibili.com/video/BV1kf4y1R7qR</a></li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/">https://www.elastic.co/guide/en/elasticsearch/reference/</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/24/ElasticSearch%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%8E%9F%E7%90%86/" data-id="ckhw55q7x000024ljc3l77h51" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-算法-二分法-一" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/16/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%B3%95-%E4%B8%80/" class="article-date">
  <time datetime="2020-11-16T06:43:08.000Z" itemprop="datePublished">2020-11-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/16/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%B3%95-%E4%B8%80/">算法-二分法(一)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="二分查找的模板"><a href="#二分查找的模板" class="headerlink" title="二分查找的模板"></a>二分查找的模板</h3><p>二分查找有很多种写法，以下是参考了网络资料后(LeetCode官方算法书)得到的二分的几种基本写法，具体参考链接将放在文章尾部。某些题目的思路中是依照自己的想法来实现的，如有错误请指正，谢谢！</p>
<h4 id="第一种写法"><a href="#第一种写法" class="headerlink" title="第一种写法"></a>第一种写法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种模板是二分查找最基础和最基本的形式，它有三种关键的属性</p>
<ul>
<li>二分查找的最基本的形式</li>
<li>查找条件可以在不与元素的两侧进行比较的时候使用</li>
<li>不需要后处理，因为在每一步中，你都在检查是否找到了元素。如果到达末尾，则知道未找到该元素。</li>
</ul>
<p><strong>例题</strong></p>
<blockquote>
<p>LeetCode69题 - x的平方根</p>
</blockquote>
<p>实现<code> int sqrt(int x)</code>函数，计算并返回x的平方根，其中x是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分舍去。</p>
<p>示例1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：4</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p>示例2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：8</span><br><span class="line">输出：2</span><br><span class="line">说明: 8 的平方根是 2.82842..., </span><br><span class="line">     由于返回类型是整数，小数部分将被舍去。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解题思路</p>
</blockquote>
<p>首先这道题是算x的平方根，那么二分的话左边界就是1，右边界就是x，循环的过程中计算mid的值，并判断mid*mid和x的大小，如果相等就说明找到了，不相等需要对左右边界做调整。并且在循环过程中要有一个变量ans来记录当前的而二分结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = x;</span><br><span class="line">        <span class="keyword">long</span> ans = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">long</span>)mid * mid &lt;= x) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                left = mid  + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>LeetCode374 - 猜数字的大小</p>
</blockquote>
<p>猜数字游戏的规则如下：</p>
<ul>
<li>每轮游戏，系统都会从 1 到 n 随机选择一个数字。 请你猜选出的是哪个数字。</li>
<li>如果你猜错了，系统会告诉你，你猜测的数字比系统选出的数字是大了还是小了。</li>
</ul>
<p>你可以通过调用一个预先定义好的接口 <code>guess(int num)</code> 来获取猜测结果，返回值一共有 3 种可能的情况<code>（-1，1 或 0）</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-1 : 你猜测的数字比系统选出的数字大</span><br><span class="line"> 1 : 你猜测的数字比系统选出的数字小</span><br><span class="line"> 0 : 恭喜！你猜对了！</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n &#x3D; 10, pick &#x3D; 6</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解题思路</p>
</blockquote>
<p>这道题应该是本科的时候学c语言写的的一个程序了，总体思路就是猜的数大了就把右边界调整一下，小了调整左边界，就直接写代码了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">GuessGame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">guessNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = n;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> res = guess(mid);</span><br><span class="line">            <span class="keyword">if</span> (res == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res == -<span class="number">1</span>) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//时间复杂度：O(logN)</span></span><br><span class="line"><span class="comment">//空间复杂度: O(1)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>LeetCode33 - 搜索旋转排序数组</p>
</blockquote>
<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2] </code>)</p>
<p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p>
<p>你可以假设数组中不存在重复的元素。</p>
<p>你的算法时间复杂度必须是 <code>O(logN) </code>级别。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0</span><br><span class="line">输出: 4</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解题思路</p>
</blockquote>
<p>这道题是一道面试中比较喜欢考的问题，也是一道比较有意思的问题，首先的问题就是旋转的排序数组是什么，不妨可以按照如下图所示来进行理解</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201001153032710.png" alt="image-20201001153032710"></p>
<p>这样的话可以发现，转折点将排序数组分成了两段，在<code>[0,1,2,4,5,6,7]</code>这个例子里两段线没有重复，那么接下来我们就需要去实现查找，具体的步骤如下：</p>
<ul>
<li>首先我们计算出中点的<strong>索引</strong>mid</li>
<li>第二步我们要去判断<code>nums[mid]</code>和target的大小<ul>
<li>如果说正好相等，那么就证明找到了，返回mid即可</li>
<li>如果不相等，这时候就需要考虑mid是在左边的线段上还是右边的线段上，因为二分查找一般只能用于有序的数组上<ul>
<li>如果mid在左边的线段上(判断条件就是<code>nums[mid] &gt;= nums[0])</code>,并且还要和target比较，如果这个时候target正好处在<code>nums[left]</code>和<code>nums[mid]</code>中间的话，那么就调整<code>right = mid - 1</code>；否则调整<code>left = mid + 1</code></li>
<li>如果mid在右边的线段上，如果target正好在<code>nums[mid]</code>和<code>nums[n - 1]</code>中间，那么调整<code>left = mid + 1</code>;否则调整<code>right = mid - 1</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>OK,到了这一步思路基本就捋清楚了，下面给出代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="comment">//边界case</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> target == nums[<span class="number">0</span>] ? <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//二分</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= nums[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt;= target &amp;&amp; target &lt;= nums[mid]) &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[n - <span class="number">1</span>] &gt;= target &amp;&amp; nums[mid] &lt;= target) &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//时间复杂度：O(logN)  N为数组长度</span></span><br><span class="line"><span class="comment">//空间复杂度：O(1)</span></span><br></pre></td></tr></table></figure>



<h4 id="第二种写法"><a href="#第二种写法" class="headerlink" title="第二种写法"></a>第二种写法</h4><p>第二种写法主要是在判断条件和后置处理上做出了一些改变，主要使用的情况包括查找需要<em>访问数组中当前索引及其直接右邻居索引</em>的元素或条件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length;</span><br><span class="line">  <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">    <span class="comment">// Prevent (left + right) overflow</span></span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target) &#123; </span><br><span class="line">            <span class="keyword">return</span> mid; </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123; </span><br><span class="line">            left = mid + <span class="number">1</span>; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            right = mid; </span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Post-processing:</span></span><br><span class="line">  <span class="comment">// End Condition: left == right</span></span><br><span class="line">  <span class="keyword">if</span>(left != nums.length &amp;&amp; nums[left] == target) <span class="keyword">return</span> left;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>关键属性<ul>
<li>一种实现二分查找的高级方法。</li>
<li>查找条件需要访问元素的直接右邻居。</li>
<li>使用元素的右邻居来确定是否满足条件，并决定是向左还是向右。</li>
<li>保证查找空间在每一步中至少有 2 个元素。</li>
<li>需要进行后处理。 当你剩下 1 个元素时，循环 / 递归结束。 需要评估剩余元素是否符合条件。</li>
</ul>
</li>
</ul>
<p><strong>例题</strong></p>
<blockquote>
<p>LeetCode278 - 第一个错误的版本</p>
</blockquote>
<p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p>
<p>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。</p>
<p>你可以通过调用 <code>bool isBadVersion(version)</code> 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定 n &#x3D; 5，并且 version &#x3D; 4 是第一个错误的版本。</span><br><span class="line"></span><br><span class="line">调用 isBadVersion(3) -&gt; false</span><br><span class="line">调用 isBadVersion(5) -&gt; true</span><br><span class="line">调用 isBadVersion(4) -&gt; true</span><br><span class="line"></span><br><span class="line">所以，4 是第一个错误的版本。 </span><br></pre></td></tr></table></figure>

<blockquote>
<p>解题思路</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">VersionControl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = n;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (isBadVersion(mid)) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>LeetCode162 - 寻找峰值</p>
</blockquote>
<p>峰值元素是指其值大于左右相邻值的元素。</p>
<p>给定一个输入数组 <code>nums</code>，其中 <code>nums[i] ≠ nums[i+1]</code>，找到峰值元素并返回其索引。</p>
<p>数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。</p>
<p>你可以假设 <code>nums[-1] = nums[n] = -∞</code>。</p>
<p>示例1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [1,2,3,1]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 3 是峰值元素，你的函数应该返回其索引 2。</span><br></pre></td></tr></table></figure>

<p>示例2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [1,2,1,3,5,6,4]</span><br><span class="line">输出: 1 或 5 </span><br><span class="line">解释: 你的函数可以返回索引 1，其峰值元素为 2；</span><br><span class="line">     或者返回索引 5， 其峰值元素为 6。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解题思路</p>
</blockquote>
<p>峰值就是两边低中间高，那么我们需要找一个元素，左边的比他小，右边的比他小，由于 <code>nums[-1] = nums[n] = -∞</code>，所以可以用二分，每次都找到中间的mid，看一下他右边的元素是不是比自己小，是的话可能他自己就是峰值，但是还需要向左去看，因此我们可以把right  = mid；这样一旦右边的元素比自己大了，证明峰值就在右边了，left = mid + 1；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>LeetCode153 - 寻找旋转数组中最小的元素</p>
</blockquote>
<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 <code>[0,1,2,4,5,6,7] </code>可能变为<code> [4,5,6,7,0,1,2]</code> )。</p>
<p>请找出其中最小的元素。</p>
<p>你可以假设数组中不存在重复元素。</p>
<p>示例1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,4,5,1,2]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p>示例2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [4,5,6,7,0,1,2]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解题思路</p>
</blockquote>
<p>同样是旋转数组，但是和上面那个找target的题目不一样的地方在于需要去比较mid旁边的数值了，因此不能用模板的第一种写法。</p>
<ul>
<li><p>首先如果数组没有被旋转肯定是最后一个元素比第一个元素大，那么直接返回第一个元素即可</p>
</li>
<li><p>否则如果数组被旋转过了，肯定就存在一个旋转点，这个点的左边部分都大于第一个元素，这个点的右边部分都小于第一个点</p>
<ul>
<li>先找到中间点mid</li>
<li>如果<code>nums[mid] &gt; nums[0]</code>,最小值就在mid右边</li>
<li>如果<code>nums[mid] &lt; nums[0]</code>,最小值就在mid左边</li>
</ul>
</li>
<li><p>当我们找到这个中间点后，右边的元素如果比当前点小，那么mid + 1就是最小值，否则就是mid是最小值</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[right] &gt; nums[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[mid + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid - <span class="number">1</span>] &gt; nums[mid]) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[mid];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[<span class="number">0</span>]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h4 id="第三种写法（个人比较爱用这种）"><a href="#第三种写法（个人比较爱用这种）" class="headerlink" title="第三种写法（个人比较爱用这种）"></a>第三种写法（个人比较爱用这种）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left + <span class="number">1</span> &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (nums[left] == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[right] == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法主要用于搜索需要<em>访问当前索引及其在数组中的直接左右邻居索引</em>的元素或条件。</p>
<p><strong>特征</strong></p>
<ul>
<li>实现二分查找的另一种方法。</li>
<li>搜索条件需要访问元素的直接左右邻居。</li>
<li>使用元素的邻居来确定它是向右还是向左。</li>
<li>保证查找空间在每个步骤中至少有 3 个元素。</li>
<li>需要进行后处理。 当剩下 2 个元素时，循环 / 递归结束。 需要评估其余元素是否符合条件。</li>
</ul>
<blockquote>
<p>LeetCode162 - 寻找峰值</p>
</blockquote>
<p>这次利用第三种模板写一次</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left + <span class="number">1</span> &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[left] &gt;= nums[right]) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><blockquote>
<p><strong>LeetCode153</strong> - 寻找排序数组中得最小值</p>
</blockquote>
<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 <code>[0,1,2,4,5,6,7] </code>可能变为<code> [4,5,6,7,0,1,2]</code> )。</p>
<p>请找出其中最小的元素。</p>
<p>你可以假设数组中不存在重复元素。</p>
<p>示例1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,4,5,1,2]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p>示例2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [4,5,6,7,0,1,2]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left + <span class="number">1</span> &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[right]) &#123;</span><br><span class="line">                <span class="comment">//证明最小值在右边的线段上</span></span><br><span class="line">                left = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//left,right</span></span><br><span class="line">        <span class="keyword">if</span> (nums[left] &lt;= nums[right]) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[left];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[right];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>LeetCode154</strong> - 寻找旋转排序数组中的最小值 II</p>
</blockquote>
<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 <code>[0,1,2,4,5,6,7] </code>可能变为<code> [4,5,6,7,0,1,2]</code> )。</p>
<p>请找出其中最小的元素。</p>
<p>假设数组中存在重复元素。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,2,0,1]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left + <span class="number">1</span> &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[left] == nums[mid]) &#123;</span><br><span class="line">                <span class="comment">//去重</span></span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[right]) &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (nums[left] &lt;= nums[right]) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[left];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[right];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>LeetCode287</strong> - 寻找重复数</p>
</blockquote>
<p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,4,2,2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,1,3,4,2]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>不能更改原数组（假设数组是只读的）。</li>
<li>只能使用额外的 O(1) 的空间。</li>
<li>时间复杂度小于 O(n^2) 。</li>
<li>数组中只有一个重复的数字，但它可能不止重复出现一次。</li>
</ul>
<blockquote>
<p>解题思路</p>
</blockquote>
<p>这道题的思路是，虽然数组是无序的，但是数组内元素的大小是1~N排列的，因此从这种意义上看是有序的，可以用二分。但是二分的话不能用第三种模板的形式，第三种形式的推出循环的条件是left+1=right，无法确定最后重复的是left还是right。因此我打算用第二种形式的模板，也就是判断条件是left &lt; right：</p>
<ul>
<li>首先随机选中一个值mid</li>
<li>判断nums数组中有多少小于等于mid 的值，用count记录下来</li>
<li>如果count大于mid了，就证明left到mid这段区间内有重复的，否则就去mid到right这段区间去找,mid肯定不是重复的，(left = mid + 1)</li>
<li>最后left == right退出循环了，也就找到了最终的结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num &lt;= mid) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (count &lt;= mid) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/16/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%B3%95-%E4%B8%80/" data-id="ckhk6n3ti0000dslj05bgbbry" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ElasticSearch基本使用(一)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/14/ElasticSearch%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8(%E4%B8%80)/" class="article-date">
  <time datetime="2020-11-14T08:02:14.000Z" itemprop="datePublished">2020-11-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/14/ElasticSearch%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8(%E4%B8%80)/">ElasticSearch基本使用(一)：Get Started与复合查询</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>学习任意一种工具，我个人习惯是先看官方文档，因此学习ElasticSearch也是一样的，但是由于ES的中文版本比较低，所以我的学习主要借鉴的是官方英文文档中ES<code>7.10X</code>的版本，因此笔记中出现的某些列子也都是官方文档中标注的。该篇文章仅仅是对ES的使用做一些简要的介绍。</p>
<hr>
<ul>
<li><p><strong>Get Started</strong></p>
<ul>
<li><p>建立Index</p>
<ul>
<li><p>通过<code>PUT</code>请求特定的index</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUT /customer/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;YoungLH&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果customer这个Index库不存在的话，那么ES会自动帮助你创建这个Index，并且按照上面的命令会创建一条ID为1的document。</p>
</li>
</ul>
</li>
<li><p>搜索操作</p>
<p>在建立了Index之后我们就可以开始去搜索相应的Index内的document数据，这时候我们会利用<code>GET</code>请求，并配合相应的<code>_search</code>字段，而在请求内部就可以利用ES的查询DSL语言去构建查询条件</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /customer/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;query&quot;</span> : &#123;</span><br><span class="line">        match_all : &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;sort&quot; : [</span><br><span class="line">        &#123;<span class="attr">&quot;account_num&quot;</span> : <span class="string">&quot;asc&quot;</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查询之后返回的相应体内<code>hits</code>字段内就包含满足条件的数据。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;took&quot;</span> : <span class="number">63</span>,</span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : <span class="number">5</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span> : <span class="number">5</span>,</span><br><span class="line">    <span class="attr">&quot;skipped&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;hits&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;value&quot;</span>: <span class="number">1000</span>,</span><br><span class="line">        <span class="attr">&quot;relation&quot;</span>: <span class="string">&quot;eq&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;max_score&quot;</span> : <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">&quot;hits&quot;</span> : [ &#123;</span><br><span class="line">      <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;bank&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;0&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;sort&quot;</span>: [<span class="number">0</span>],</span><br><span class="line">      <span class="attr">&quot;_score&quot;</span> : <span class="literal">null</span>,</span><br><span class="line">      <span class="attr">&quot;_source&quot;</span> : &#123;<span class="attr">&quot;account_number&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;balance&quot;</span>:<span class="number">16623</span>,<span class="attr">&quot;firstname&quot;</span>:<span class="string">&quot;Bradshaw&quot;</span>,<span class="attr">&quot;lastname&quot;</span>:<span class="string">&quot;Mckenzie&quot;</span>,<span class="attr">&quot;age&quot;</span>:<span class="number">29</span>,<span class="attr">&quot;gender&quot;</span>:<span class="string">&quot;F&quot;</span>,<span class="attr">&quot;address&quot;</span>:<span class="string">&quot;244 Columbus Place&quot;</span>,<span class="attr">&quot;employer&quot;</span>:<span class="string">&quot;Euron&quot;</span>,<span class="attr">&quot;email&quot;</span>:<span class="string">&quot;bradshawmckenzie@euron.com&quot;</span>,<span class="attr">&quot;city&quot;</span>:<span class="string">&quot;Hobucken&quot;</span>,<span class="attr">&quot;state&quot;</span>:<span class="string">&quot;CO&quot;</span>&#125;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;bank&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;sort&quot;</span>: [<span class="number">1</span>],</span><br><span class="line">      <span class="attr">&quot;_score&quot;</span> : <span class="literal">null</span>,</span><br><span class="line">      <span class="attr">&quot;_source&quot;</span> : &#123;<span class="attr">&quot;account_number&quot;</span>:<span class="number">1</span>,<span class="attr">&quot;balance&quot;</span>:<span class="number">39225</span>,<span class="attr">&quot;firstname&quot;</span>:<span class="string">&quot;Amber&quot;</span>,<span class="attr">&quot;lastname&quot;</span>:<span class="string">&quot;Duke&quot;</span>,<span class="attr">&quot;age&quot;</span>:<span class="number">32</span>,<span class="attr">&quot;gender&quot;</span>:<span class="string">&quot;M&quot;</span>,<span class="attr">&quot;address&quot;</span>:<span class="string">&quot;880 Holmes Lane&quot;</span>,<span class="attr">&quot;employer&quot;</span>:<span class="string">&quot;Pyrami&quot;</span>,<span class="attr">&quot;email&quot;</span>:<span class="string">&quot;amberduke@pyrami.com&quot;</span>,<span class="attr">&quot;city&quot;</span>:<span class="string">&quot;Brogan&quot;</span>,<span class="attr">&quot;state&quot;</span>:<span class="string">&quot;IL&quot;</span>&#125;</span><br><span class="line">    &#125;, ...</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了<code>hits</code>字段外，其余的字段分别为：</p>
<ul>
<li><p><code>took</code>：这段查询花费了多长时间，单位为毫秒</p>
</li>
<li><p><code>time_out</code>：这段查询是不是超时了</p>
</li>
<li><p><code>_shards</code>：查询后有多少个分片成功、失败或者是被跳过</p>
</li>
<li><p><code>max_score</code>：最匹配的那条document数据的分数</p>
</li>
<li><p><code>hits.total.value</code>：有多少个document被找到</p>
</li>
<li><p><code>hits.sort</code>：对document的排序</p>
</li>
<li><p><code>hits._sort</code>：document的相关度分数（在使用<code>match_all</code>的时候是不起作用的）</p>
<p>如果说还想用分页查询，那么可以在请求体内加入<code>from</code>和<code>size字段</code></p>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123; <span class="attr">&quot;match_all&quot;</span>: &#123;&#125; &#125;,</span><br><span class="line">  <span class="attr">&quot;sort&quot;</span>: [</span><br><span class="line">    &#123; <span class="attr">&quot;account_number&quot;</span>: <span class="string">&quot;asc&quot;</span> &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;from&quot;</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">&quot;size&quot;</span>: <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进一步的，如果说想要构建更精准的查询，我们在请求体内就不会继续使用<code>match_all</code>这个字段了。</p>
<p>为了精确匹配某些字段，我们一般都使用<code>match</code>查询，例如在官方文档中的例子：比如我们要查询的是地址中包含mill或者lane的信息：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;query&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;match&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;address&quot;</span> : <span class="string">&quot;mill lane&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但如果我们要查询的是整个句子而不是单个的单词，我们可以试用<code>match_phrase</code>去匹配</p>
<p>此外，如果想进一步做复杂查询，我们就可以试用<code>bool</code>查询去包含多个查询条件，一般来说分成must match、should match、must not match</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;must&quot;</span>: [</span><br><span class="line">        &#123; <span class="attr">&quot;match&quot;</span>: &#123; <span class="attr">&quot;age&quot;</span>: <span class="string">&quot;40&quot;</span> &#125; &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;must_not&quot;</span>: [</span><br><span class="line">        &#123; <span class="attr">&quot;match&quot;</span>: &#123; <span class="attr">&quot;state&quot;</span>: <span class="string">&quot;ID&quot;</span> &#125; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样我们还可以对结果进行过滤</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;must&quot;</span>: &#123; <span class="attr">&quot;match_all&quot;</span>: &#123;&#125; &#125;,</span><br><span class="line">      <span class="attr">&quot;filter&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;range&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;balance&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;gte&quot;</span>: <span class="number">20000</span>,</span><br><span class="line">            <span class="attr">&quot;lte&quot;</span>: <span class="number">30000</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p><strong>查询DSL语句</strong></p>
<p>在完成了前面的Get Started之后，我们来看一下官方文档中给出的具体的DSL语句。</p>
<p>官方文档中给出ES有两种基本的查询：一种是叶子查询子句，另一种是复合查询子句，叶子查询子句是在特定字段中查找特定值，例如使用<code>match</code>，<code>term</code>，<code>range</code>查询。而复合查询子句可以包含其它的叶子查询语句或者复合查询语句，然后将它们用一定的逻辑组合起来，比如使用<code>bool</code>查询或者<code>dis_max</code>查询。具体查询子句做了什么是依据这些子句是在查询上下文中还是说在过滤器上下文中。</p>
<p>那什么是查询上下文和过滤器上下文呢？</p>
<p>首先我们要介绍几个概念：</p>
<ul>
<li><p>相关度分值</p>
<p>默认情况下ES对于匹配到的搜索结果进行排序都是依照相关度分值进行的，它体现的是每条document数据和这条查询中匹配的程度。这个分值会存储在<code>_score</code>这个字段中进行返回。同时这个分值的计算归根到底也是依据我们的查询语句是在查询上下文中还是过滤器上下文中。</p>
</li>
<li><p>查询上下文</p>
<p>在查询上下文中，查询子句回答以下问题：“此文档与该查询子句的匹配程度如何？” 除了确定文档是否匹配之外，查询子句还计算<code>_score</code>元数据字段中的相关性得分。</p>
<p>只要将查询子句传递到查询参数（例如搜索API中的查询参数），查询上下文就有效。</p>
</li>
<li><p>过滤器上下文</p>
<p>在过滤器上下文中，查询子句回答问题“此文档与该查询子句匹配吗？” 答案是简单的“是”或“否”，即不计算分数。 过滤器上下文主要用于过滤结构化数据，例如</p>
<p>此时间戳记是否在2015年至2016年的范围内？<br>状态字段设置为“已发布”吗？<br>常用的过滤器将由ElasticSearch自动缓存，以提高性能。</p>
<p>每当将查询子句传递到过滤器参数（例如bool查询中的filter或must_not参数，constant_score查询中的filter参数或过滤器聚合）时，过滤器上下文即生效。</p>
</li>
<li><p>例子</p>
<p>下面我们来看一下官方文档中的例子：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123; <span class="comment">//1</span></span><br><span class="line">    <span class="attr">&quot;bool&quot;</span>: &#123; <span class="comment">//2</span></span><br><span class="line">      <span class="attr">&quot;must&quot;</span>: [</span><br><span class="line">        &#123; <span class="attr">&quot;match&quot;</span>: &#123; <span class="attr">&quot;title&quot;</span>:   <span class="string">&quot;Search&quot;</span>        &#125;&#125;,</span><br><span class="line">        &#123; <span class="attr">&quot;match&quot;</span>: &#123; <span class="attr">&quot;content&quot;</span>: <span class="string">&quot;Elasticsearch&quot;</span> &#125;&#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;filter&quot;</span>: [<span class="comment">//3 </span></span><br><span class="line">        &#123; <span class="attr">&quot;term&quot;</span>:  </span><br><span class="line">         &#123; <span class="attr">&quot;status&quot;</span>: <span class="string">&quot;published&quot;</span> </span><br><span class="line">         &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123; <span class="attr">&quot;range&quot;</span>: </span><br><span class="line">         &#123; <span class="attr">&quot;publish_date&quot;</span>: </span><br><span class="line">          &#123; <span class="attr">&quot;gte&quot;</span>: <span class="string">&quot;2015-01-01&quot;</span> &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li> <code>query</code>字段表示是查询上下文。</li>
<li> <code>bool</code>和两个<code>match</code>字段是在<code>query</code>字段内使用的，因此这就意味着他们搜索的结果会被计算相关度分值。</li>
<li> <code>filter</code>字段说明是过滤器上下文，在上面的例子中里面包含了<code>term</code>和<code>range</code>字段，他们就会过滤出那些符合条件的document数据，但是并不会影响上面计算的相关度分值。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>复合查询</p>
<p>复合查询一般包括以下几种：</p>
<ul>
<li><p><code>bool</code>查询</p>
<p>默认查询，用于组合多个叶子或复合查询子句（<code>must</code>，<code>should</code>，<code>must_not</code>或<code>filter</code>子句）。 must和should子句的分数组合在一起-匹配的子句越多越好-而must_not和filter子句在过滤器上下文中执行。</p>
</li>
<li><p><code>boosting</code>查询</p>
<p>返回与正查询匹配的文档，但减少也与负查询匹配的文档的分数。</p>
</li>
<li><p><code>constant_score</code>查询</p>
<p>它包装另一个查询，但在过滤器上下文中执行它。所有匹配的文档都使用相同的常数_score。</p>
</li>
<li><p><code>dis_max</code>查询</p>
<p>它接受多个查询，并返回与任何查询子句匹配的任何文档。当布尔查询合并所有匹配查询的分数时，dis_max查询使用单个最佳匹配查询子句的分数。</p>
</li>
<li><p><code>function_score</code>查询</p>
<p>这个是使用自己定义的算法进行查询。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><code>bool</code>查询</p>
<p><code>bool</code>查询中主要包含下面几种字段：</p>
<ul>
<li><p><code>must</code></p>
<p>查询子句必须包含的字段。</p>
</li>
<li><p><code>filter</code></p>
<p>这个字段负责过滤，但不会参与到相关度分值的计算。</p>
</li>
<li><p><code>should</code></p>
<p>或的逻辑。</p>
</li>
<li><p><code>must_not</code></p>
<p>指定不能出现在查询结果中的字段。</p>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">POST _search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;bool&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;must&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;term&quot;</span> : &#123; <span class="attr">&quot;user.id&quot;</span> : <span class="string">&quot;kimchy&quot;</span> &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;filter&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;term&quot;</span> : &#123; <span class="attr">&quot;tags&quot;</span> : <span class="string">&quot;production&quot;</span> &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;must_not&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;range&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;age&quot;</span> : &#123; <span class="attr">&quot;gte&quot;</span> : <span class="number">10</span>, <span class="attr">&quot;lte&quot;</span> : <span class="number">20</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;should&quot;</span> : [</span><br><span class="line">        &#123; <span class="attr">&quot;term&quot;</span> : &#123; <span class="attr">&quot;tags&quot;</span> : <span class="string">&quot;env1&quot;</span> &#125; &#125;,</span><br><span class="line">        &#123; <span class="attr">&quot;term&quot;</span> : &#123; <span class="attr">&quot;tags&quot;</span> : <span class="string">&quot;deployed&quot;</span> &#125; &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;minimum_should_match&quot;</span> : <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;boost&quot;</span> : <span class="number">1.0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>给<code>bool.filter</code>分配score</p>
<p>首先，我们从前文可以看到，分布在<code>filter</code>标签下的查询语句对于score是没有影响的，也就是说在过滤器上下文下的查询语句返回的相关度分值是0。只有查询语句在精确匹配的前提下才会有score。</p>
</li>
<li><p><code>named</code>查询</p>
<p>每个查询都接收一个<code>_name</code>字段，我们可以使用<code>named</code>查询去跟踪哪些查询与返回的结果文档匹配。如果使用了<code>named</code>查询，那么在返回的响应中每一个命中的document都会包含<code>matched_queries</code>这个属性字段。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;should&quot;</span>: [</span><br><span class="line">        &#123; <span class="attr">&quot;match&quot;</span>: &#123; <span class="attr">&quot;name.first&quot;</span>: &#123; <span class="attr">&quot;query&quot;</span>: <span class="string">&quot;shay&quot;</span>, <span class="attr">&quot;_name&quot;</span>: <span class="string">&quot;first&quot;</span> &#125; &#125; &#125;,</span><br><span class="line">        &#123; <span class="attr">&quot;match&quot;</span>: &#123; <span class="attr">&quot;name.last&quot;</span>: &#123; <span class="attr">&quot;query&quot;</span>: <span class="string">&quot;banon&quot;</span>, <span class="attr">&quot;_name&quot;</span>: <span class="string">&quot;last&quot;</span> &#125; &#125; &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;filter&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;terms&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;name.last&quot;</span>: [ <span class="string">&quot;banon&quot;</span>, <span class="string">&quot;kimchy&quot;</span> ],</span><br><span class="line">          <span class="attr">&quot;_name&quot;</span>: <span class="string">&quot;test&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>boosting</code>查询</p>
<p><code>boosting</code>查询会返回匹配了<code>positive</code>查询字段的那些document，然而如果这条查询也匹配到了<code>negative</code>查询，返回的结果就会减低document的相关度分数。</p>
<p>应用场景：我们可以使用<code>boosting</code>查询去对某些查询结果进行降级，而不是说从搜索结果中将其剔除。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;boosting&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;positive&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;term&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;apple&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;negative&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;term&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;pie tart fruit crumble tree&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;negative_boost&quot;</span>: <span class="number">0.5</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那问题就是怎么降级？官方文档中给出了相应的解释：</p>
<p>在<code>negative</code>字段下面还有一个<code>negative_boost</code>字段，我们可以指定这个字段的value值，比如上面例子的0.5。那么具体的降级计算过程就是：</p>
<ul>
<li>首先拿到初始的<code>positive</code>查询的相关度分数</li>
<li>将上面的分数乘以<code>negative_boost</code>的值，就是降级后的结果。<ul>
<li>注意：<code>negative_boost</code>字段的值一般是浮点数，从0到1.0之间</li>
</ul>
</li>
</ul>
</li>
<li><p><code>constant score</code>查询</p>
<p>包装过滤查询，并返回相关度分数等于boost参数值的每个匹配文档。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;constant_score&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;filter&quot;</span>: &#123;<span class="comment">//过滤后的结果会被缓存</span></span><br><span class="line">        <span class="attr">&quot;term&quot;</span>: &#123; <span class="attr">&quot;user.id&quot;</span>: <span class="string">&quot;kimchy&quot;</span> &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;boost&quot;</span>: <span class="number">1.2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>disjunction max</code>查询</p>
<p>它接受多个查询，并返回与任何查询子句匹配的任何文档。当布尔查询合并所有匹配查询的分数时，dis_max查询使用单个最佳匹配查询子句的分数。</p>
<p>我们可以使用<code>dis_max</code>字段在不同的boost因子映射的字段中去搜索</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;dis_max&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;queries&quot;</span>: [</span><br><span class="line">        &#123; <span class="attr">&quot;term&quot;</span>: &#123; <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;Quick pets&quot;</span> &#125; &#125;,</span><br><span class="line">        &#123; <span class="attr">&quot;term&quot;</span>: &#123; <span class="attr">&quot;body&quot;</span>: <span class="string">&quot;Quick pets&quot;</span> &#125; &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;tie_breaker&quot;</span>: <span class="number">0.7</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>queries</code></p>
<p>这个字段包含一个或者多个查询子句，同样返回的字段中也必须匹配一个或者多个查询。如果一个文档匹配了多个查询，那么ES会返回的是最高的相关度分数。</p>
</li>
<li><p><code>tie_breaker</code></p>
<p>这是一个可选字段，是一个0到1.0之间的浮点数。我们可以通过给多个字段中包含相同术语的文档分配更好的包含该术语的相关度分数，从而避免混淆。</p>
<p>具体的计算流程：</p>
<ul>
<li>首先拿到匹配子句的最高相关度分值</li>
<li>将上述结果乘以我们设置的<code>tie_breaker</code>值</li>
<li>将最高的分值加到我们第二步的分值上去</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>参考文献</strong><ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-bool-query.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-bool-query.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-boosting-query.html#boosting-query-ex-request">https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-boosting-query.html#boosting-query-ex-request</a></li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-constant-score-query.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-constant-score-query.html</a></li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/14/ElasticSearch%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8(%E4%B8%80)/" data-id="ckhw4sfem0000vslj72g21pay" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/11/24/ElasticSearch%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%8E%9F%E7%90%86/">ElasticSearch基本概念与原理</a>
          </li>
        
          <li>
            <a href="/2020/11/16/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%B3%95-%E4%B8%80/">算法-二分法(一)</a>
          </li>
        
          <li>
            <a href="/2020/11/14/ElasticSearch%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8(%E4%B8%80)/">ElasticSearch基本使用(一)：Get Started与复合查询</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Larry Young<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>