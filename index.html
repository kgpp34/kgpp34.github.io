<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>多模型自适应混子的技术老巢</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="多模型自适应混子的技术老巢">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="多模型自适应混子的技术老巢">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Larry Young">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="多模型自适应混子的技术老巢" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">多模型自适应混子的技术老巢</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-MIT6-824分布式系统Lab1-MapReduce" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/31/MIT6-824%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9FLab1-MapReduce/" class="article-date">
  <time datetime="2020-12-31T07:13:13.000Z" itemprop="datePublished">2020-12-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/31/MIT6-824%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9FLab1-MapReduce/">MIT6.824分布式系统Lab1-MapReduce</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为学习分布式系统的一门课程，MIT6.824一直都是国内外质量上乘的课程之一，知乎上很多经验丰富的软件开发人员也都是力推这门课程，而它的好处就是在于教授的授课是结合学生课前阅读论文、上课讲述思路以及课后的lab共同组成，会很大程度上的让学生独立地从0到1去实现一个编程模型，而不是仅仅使用各个厂家的框架。</p>
<p>那么我跟随的课程是2020春季学期的这门课程，课程地址为：<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/schedule.html%EF%BC%8C%E5%9C%A8schedule%E7%95%8C%E9%9D%A2%E5%86%85%E4%BD%A0%E5%8F%AF%E4%BB%A5%E9%80%89%E6%8B%A9%E6%83%B3%E8%A6%81%E5%AE%8C%E6%88%90%E7%9A%84lab%E5%92%8C%E6%83%B3%E8%A6%81%E9%98%85%E8%AF%BB%E7%9A%84%E6%96%87%E7%8C%AE%E7%AD%89%E7%AD%89%EF%BC%8C%E5%9C%A8%E8%BF%99%E9%87%8C%E5%B0%B1%E4%B8%8D%E5%86%8D%E8%B5%98%E8%BF%B0%E4%BA%86%EF%BC%8C%E5%B0%B1%E7%9B%B4%E6%8E%A5%E5%88%87%E5%85%A5%E6%AD%A3%E9%A2%98%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97%E6%A1%86%E6%9E%B6MapReduce%E7%9A%84lab%E5%AE%9E%E9%AA%8C%E9%83%A8%E5%88%86(**Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0**)%E3%80%82">https://pdos.csail.mit.edu/6.824/schedule.html，在schedule界面内你可以选择想要完成的lab和想要阅读的文献等等，在这里就不再赘述了，就直接切入正题，也就是分布式计算框架MapReduce的lab实验部分(**Go语言实现**)。</a></p>
<ul>
<li>注：其实Go很好上手，我实习的时候学了4天，然后下一周就进了项目，不会的童鞋可以参考Go语言之旅这个简短的教程来熟悉Go，地址是<a target="_blank" rel="noopener" href="https://tour.go-zh.org/list">https://tour.go-zh.org/list</a></li>
</ul>
<hr>
<h2 id="MapReduce原理"><a href="#MapReduce原理" class="headerlink" title="MapReduce原理"></a>MapReduce原理</h2><p>如果你还没有读过<code>MapReduce</code>的论文，那么最好还是看一下，这样能够很快速的理解它的思想，我在这里就先总结一下。</p>
<p>首先，<code>MapReduce</code>是一个能够处理和生成大量数据集的分布式的编程模型，它的结论就是通过给程序开发人员提供<code>map</code>和<code>reduce</code>两个函数来分别实现产生<code>(k,v)</code>中间结果和将相同<code>key</code>的数据进行汇总归并的操作，这样<code>map</code>和<code>reduce</code>两个函数其实就可以在不同的机器上进行运行，从而提高我们计算的效率。</p>
<p>在论文中，最重要的部分也就是下面这张图：</p>
<p>![](F:\YoungLH’s blog\source\images\MapReduce原理.jpg)</p>
<p>这张图里面有几个比较重要的部分：</p>
<ul>
<li><p>Master进程</p>
<p>它是用来分配任务给worker进程的角色，他来决定worker执行的是<code>map</code>函数还是<code>reduce</code>函数</p>
</li>
<li><p>worker进程</p>
<p>如果worker进程执行的是<code>map</code>函数，那么它就要读取已经分片了的输入文件，处理文件内的每一行，然后将文件转换成<code>(k,v)</code>这样形式的中间文件；而如果它被指定为要执行<code>reduce</code>函数，那么worker就需要去读取中间文件(这个过程是通过<code>RPC</code>实现的)，然后对中间文件的<code>key</code>先做排序，然后根据排序的结果做归并的处理。</p>
</li>
</ul>
<p>除此之外，就是还要留意一下中间文件的个数，这个个数是由用户程序指定的，然后怎么选择用哪个<code>reduce</code>程序执行是通过公式<code>hash(key) mod R</code>进行选择。</p>
<hr>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>课程给出了相应的例子，具体的代码路径是<code>src\main\mrsequential.go</code>，这个例子给出的是非分布式版本的，而我们需要实现的是分布式版本的，具体来说我们需要完成<code>src\mr</code>下面的<code>master.go</code>, <code>worker.go</code>和<code>rpc.go</code>三个程序，</p>
<p>首先，我从<code>worker</code>来开始着手写，每个<code>worker</code>都需要通过<code>rpc</code>和<code>master</code>进行通信来申请一个任务(具体是map还是reduce任务是由master来决定的)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// main/mrworker.go calls this function.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Worker</span><span class="params">(mapf <span class="keyword">func</span>(<span class="keyword">string</span>, <span class="keyword">string</span>)</span> []<span class="title">KeyValue</span>,</span></span><br><span class="line">	reducef <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>, []<span class="keyword">string</span>)</span> <span class="title">string</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Your worker implementation here.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// uncomment to send the Example RPC to the master.</span></span><br><span class="line">	<span class="comment">// CallExample()</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是作业中的Worker函数，我们也是需要在这个函数里实现我们的<code>worker</code>函数，那么思路就是：</p>
<ul>
<li>向<code>master</code>请求任务</li>
<li>针对返回来的任务类型，做不同的处理<ul>
<li>返回任务类型是<code>map</code>：调用<code>Map</code>函数</li>
<li>返回任务类型是<code>reduce</code>：调用<code>Reduce</code>函数</li>
<li>还有两种特殊情况，就是任务等待和任务终止，分别延时一段时间和直接返回</li>
<li>默认情况抛异常</li>
</ul>
</li>
</ul>
<p>那么代码写出来就是这样的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// main/mrworker.go calls this function.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Worker</span><span class="params">(mapf <span class="keyword">func</span>(<span class="keyword">string</span>, <span class="keyword">string</span>)</span> []<span class="title">KeyValue</span>,</span></span><br><span class="line">	reducef <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>, []<span class="keyword">string</span>)</span> <span class="title">string</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Your worker implementation here.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// uncomment to send the Example RPC to the master.</span></span><br><span class="line">	<span class="comment">// CallExample()</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">//请求任务(rpc调用)</span></span><br><span class="line">        taskInfo := CallTask()</span><br><span class="line">        <span class="keyword">switch</span> taskInfo.State &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            	Map(mapf, )</span><br><span class="line">            	<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            	Reduce(reducef, )</span><br><span class="line">            	<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            	time.sleep(time.Duration(time.Second * <span class="number">10</span>))</span><br><span class="line">            	<span class="keyword">break</span>;</span><br><span class="line">        	<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            	fmt.Println(<span class="string">&quot; all of tasks have completed, nothing to do...&quot;</span>)</span><br><span class="line">            	<span class="keyword">return</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            	<span class="built_in">panic</span>(<span class="string">&quot;Invaild State of Worker, Please try again....&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到这里面我们用到了<code>CallTask()</code>这个函数用来向master请求任务,在这个函数中我们需要调用提供给我们的<code>call()</code>函数，最后返回了一个<code>taskInfo</code>对象，根据对象中的<code>State</code>决定怎么样处理，那么我们在<code>worker.go</code>中先要实现<code>CallTask()</code>方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CallTask</span><span class="params">()</span> *<span class="title">TaskInfo</span></span> &#123;</span><br><span class="line">    args := ExampleArgs&#123;&#125;</span><br><span class="line">    reply := TaskInfo&#123;&#125;</span><br><span class="line">    <span class="comment">//通过rpc调用Master的RequireTask方法</span></span><br><span class="line">    call(<span class="string">&quot;Master.RequireTask&quot;</span>, &amp;args, &amp;reply)</span><br><span class="line">    <span class="keyword">return</span> &amp;reply</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">call</span><span class="params">(rpcname <span class="keyword">string</span>, args <span class="keyword">interface</span>&#123;&#125;, reply <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="comment">// c, err := rpc.DialHTTP(&quot;tcp&quot;, &quot;127.0.0.1&quot;+&quot;:1234&quot;)</span></span><br><span class="line">    <span class="comment">//masterSock()方法是在rpc.go中，返回的是UNIX域下socket的名字</span></span><br><span class="line">	sockname := masterSock()</span><br><span class="line">	c, err := rpc.DialHTTP(<span class="string">&quot;unix&quot;</span>, sockname)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;dialing:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> c.Close()</span><br><span class="line"></span><br><span class="line">	err = c.Call(rpcname, args, reply)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(err)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了完成这两个函数，我们还需要定义一下<code>taskInfo</code>的内容，即<code>TaskInfo</code>类，写在<code>rpc.go</code>中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TaskInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">/*** state value </span></span><br><span class="line"><span class="comment">    * 0 --&gt; map</span></span><br><span class="line"><span class="comment">      1 --&gt; reduce</span></span><br><span class="line"><span class="comment">      2 --&gt; wait</span></span><br><span class="line"><span class="comment">      3 --&gt; nothing to do</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    State        <span class="keyword">int</span></span><br><span class="line">    <span class="comment">//要读取的文件名</span></span><br><span class="line">    FileName     <span class="keyword">string</span></span><br><span class="line">    <span class="comment">//经过map后输出到哪个file中--&gt;针对map</span></span><br><span class="line">    FileIdx      <span class="keyword">int</span> </span><br><span class="line">    <span class="comment">//要写到哪个文件--&gt;针对reduce</span></span><br><span class="line">    OutFileIdx   <span class="keyword">int</span></span><br><span class="line">    <span class="comment">//分成几个reduce</span></span><br><span class="line">    ReduceNum    <span class="keyword">int</span></span><br><span class="line">    FileNum      <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成了上面步骤之后，现在就需要回到<code>Worker</code>方法中，然后我们需要进入到<code>switch</code>中，看到我们还有两个函数没有实现，即<code>Map</code>和<code>Reduce</code>：对于前者而言，输入的参数除了一个<code>mapf</code>函数之外，还需要把任务信息传递进来，因为任务信息包含了你要读入文件的名称和<code>index</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Map</span><span class="params">(mapf <span class="keyword">func</span>(<span class="keyword">string</span>, <span class="keyword">string</span>)</span> []<span class="title">KeyValue</span>, <span class="title">taskInfo</span> *<span class="title">TaskInfo</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//根据文件名读文件，并将调用mapf之后输出的kv保存在中间数组中</span></span><br><span class="line">    interFile := []KeyValue</span><br><span class="line">    file, err := os.Open(taskInfo.FileName)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    content, err := ioutil.ReadAll(file)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    file.Close()</span><br><span class="line">    kvs := mapf(taskInfo.FileName, <span class="keyword">string</span>(content))</span><br><span class="line">    interFile = <span class="built_in">append</span>(interFile, kvs...)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//准备输出文件</span></span><br><span class="line">    outPrefix = <span class="string">&quot;mr-tmp/mr-&quot;</span></span><br><span class="line">    outPrefix += strconv.Itoa(taskInfo.FileIdx)</span><br><span class="line">    outFiles := <span class="built_in">make</span>([]*os.File, taskInfo.ReduceNum)</span><br><span class="line">    outFilesEncode := <span class="built_in">make</span>([]*json.Encoder, taskInfo.ReduceNum)</span><br><span class="line">    <span class="keyword">for</span> idx := <span class="number">0</span>; idx &lt; taskInfo.ReduceNum; idx++ &#123;</span><br><span class="line">        <span class="comment">//在mr-tmp文件夹下生成空的临时文件并设置编码</span></span><br><span class="line">        outFiles[idx], _ = ioutil.TempFile(<span class="string">&quot;mr-tmp&quot;</span>, <span class="string">&quot;mr-tmp-*&quot;</span>)</span><br><span class="line">        outFilesEncode[idx] = json.NewEncoder(outFiles[idx])</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//依据不同的key路由存储到到不同的文件中去</span></span><br><span class="line">    <span class="keyword">for</span> _, kv := <span class="keyword">range</span> interFile &#123;</span><br><span class="line">        outputIdx := ihash(kv.Key) % taskInfo.ReduceNum</span><br><span class="line">        file = outFiles[outputIdx]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//保存文件</span></span><br><span class="line">    <span class="keyword">for</span> idx, file := <span class="keyword">range</span> outFiles &#123;</span><br><span class="line">        outName := outPrefix + strconv.Itoa(idx)</span><br><span class="line">        oldPath := filepath.Join(file.Name())</span><br><span class="line">        os.Rename(oldPath, outname)</span><br><span class="line">        file.Close()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通知master我map做完了</span></span><br><span class="line">    TaskDone(taskInfo)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reduce</span><span class="params">(reducef <span class="keyword">func</span>(<span class="keyword">string</span>, []<span class="keyword">string</span>)</span> <span class="title">string</span>, <span class="title">taskInfo</span> *<span class="title">TaskInfo</span>)</span> &#123;</span><br><span class="line">    outName := <span class="string">&quot;mr-out-&quot;</span> + strconv.Itoa(taskInfo.OutFileIdx)</span><br><span class="line">    interPrefix := <span class="string">&quot;mr-tmp/mr-&quot;</span></span><br><span class="line">    interSuffix := <span class="string">&quot;-&quot;</span> + strconv.Itoa(taskInfo.OutFileIdx)</span><br><span class="line">    </span><br><span class="line">    interFile := []KeyValue&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> idx := <span class="number">0</span>; idx &lt; taskInfo.FileNum; idx++ &#123;</span><br><span class="line">        inname := interPrefix + strconv.Itoa(idx) + interSuffix</span><br><span class="line">		file, err := os.Open(inname)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Open intermediate file %v failed: %v\n&quot;</span>, inname, err)</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">&quot;Open file error&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		dec := json.NewDecoder(file)</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">var</span> kv KeyValue</span><br><span class="line">			<span class="keyword">if</span> err := dec.Decode(&amp;kv); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			interFile = <span class="built_in">append</span>(interFile, kv)</span><br><span class="line">		&#125;</span><br><span class="line">		file.Close()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sort.Sort(ByKey(interFile))</span><br><span class="line">    </span><br><span class="line">    ofile, err := ioutil.TempFile(<span class="string">&quot;mr-tmp&quot;</span>, <span class="string">&quot;mr-*&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Create output file %v failed: %v\n&quot;</span>, outname, err)</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;Create file error&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i &lt; <span class="built_in">len</span>(intermediate) &#123;</span><br><span class="line">		j := i + <span class="number">1</span></span><br><span class="line">		<span class="keyword">for</span> j &lt; <span class="built_in">len</span>(interFile) &amp;&amp; interFile[j].Key == interFile[i].Key &#123;</span><br><span class="line">			j++</span><br><span class="line">		&#125;</span><br><span class="line">		values := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">		<span class="keyword">for</span> k := i; k &lt; j; k++ &#123;</span><br><span class="line">			values = <span class="built_in">append</span>(values, interFile[k].Value)</span><br><span class="line">		&#125;</span><br><span class="line">		output := reducef(interFile[i].Key, values)</span><br><span class="line"></span><br><span class="line">		fmt.Fprintf(ofile, <span class="string">&quot;%v %v\n&quot;</span>, intermediate[i].Key, output)</span><br><span class="line"></span><br><span class="line">		i = j</span><br><span class="line">	&#125;</span><br><span class="line">	os.Rename(filepath.Join(ofile.Name()), outName)</span><br><span class="line">	ofile.Close()</span><br><span class="line">	<span class="comment">// acknowledge master</span></span><br><span class="line">	TaskDone(taskInfo)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>这样，我们就完成了<code>worker.go</code>的内容，现在我们需要考虑<code>master.go</code>的结构。</p>
<p>首先我们都知道每个任务都包含的信息都已经写在了<code>rpc.go/TaskInfo</code>中,但是在master中，我们得管理每一个任务，因此我们就需要有一个类来保存任务的状态：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TaskStat <span class="keyword">struct</span>&#123;</span><br><span class="line">    fileName       <span class="keyword">string</span></span><br><span class="line">    startTime      time.Time</span><br><span class="line">    fileIndex      <span class="keyword">int</span></span><br><span class="line">    outFileIndex <span class="keyword">int</span></span><br><span class="line">    reduceNum      <span class="keyword">int</span></span><br><span class="line">    fileNum        <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后还要定义两个类继承这个任务信息类</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MapTask <span class="keyword">struct</span> &#123;</span><br><span class="line">    TaskStat</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReduceTask <span class="keyword">struct</span> &#123;</span><br><span class="line">    TaskStat</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了对应的实现类以后我们还需要定义对外的接口，以提供获取任务信息的功能</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TaskInfoInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">    GenerateTask()      TaskInfo</span><br><span class="line">    OutOfTime()         <span class="keyword">bool</span></span><br><span class="line">    GetFileIndex()      <span class="keyword">int</span></span><br><span class="line">    GetOutFileIndex()   <span class="keyword">int</span></span><br><span class="line">    SetTime()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有的任务类都要实现上面的方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MapTask)</span> <span class="title">GenerateTaskInfo</span><span class="params">()</span> <span class="title">TaskInfo</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> TaskInfo &#123;</span><br><span class="line">        State: <span class="number">0</span></span><br><span class="line">        FileName:   this.fileName</span><br><span class="line">        FileIdx:    this.fileIndex</span><br><span class="line">        OutFileIdx: this.outFileIndex</span><br><span class="line">        ReduceNum:  this.reduceNum</span><br><span class="line">        FileNum:    this.fileNum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *ReduceTask)</span> <span class="title">GenerateTaskInfo</span><span class="params">()</span> <span class="title">TaskInfo</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> TaskInfo &#123;</span><br><span class="line">        State: <span class="number">1</span></span><br><span class="line">        FileName:   this.fileName</span><br><span class="line">        FileIdx:    this.fileIndex</span><br><span class="line">        OutFileIdx: this.outFileIndex</span><br><span class="line">        ReduceNum:  this.reduceNum</span><br><span class="line">        FileNum:    this.fileNum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *TaskStat)</span> <span class="title">OutOfTime</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> time.Now().Sub(this.startTime) &gt; time.Duration(time, Second * <span class="number">60</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *TaskStat)</span> <span class="title">GetFileIndex</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.fileIndex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *TaskStat)</span> <span class="title">GetOutFileIndex</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.outFileIndex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *TaskStat)</span> <span class="title">SetTime</span><span class="params">()</span></span> &#123;</span><br><span class="line">    this.startTime = time.Now()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外我们定义一下<code>master</code>类和两个由<code>worker</code>请求的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Master <span class="keyword">struct</span> &#123;</span><br><span class="line">    fileNames []<span class="keyword">string</span></span><br><span class="line">    </span><br><span class="line">    mapRunningTaskChannel <span class="keyword">chan</span> TaskStat</span><br><span class="line">    mapWaitingTaskChannel <span class="keyword">chan</span> TaskStat</span><br><span class="line">    reduceRunningTaskChannel <span class="keyword">chan</span> TaskStat</span><br><span class="line">    reduceWaitingTaskChannel <span class="keyword">chan</span> TaskStat</span><br><span class="line">    </span><br><span class="line">    isDone <span class="keyword">bool</span></span><br><span class="line">    reduceNum <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Master)</span> <span class="title">RequireTask</span><span class="params">(args *ExampleArgs, reply *TaskInfo)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> this.isDone &#123;</span><br><span class="line">        reply.State = <span class="number">3</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mapTask := &lt;- mapWaitingTaskChannel</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> mapTask != <span class="literal">nil</span> &#123;</span><br><span class="line">        mapTask.setTime()</span><br><span class="line">        mapRunningTaskChannel &lt;- mapTask</span><br><span class="line">        *reply = mapTask.GenerateTaskInfo()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reduceTask := &lt;- reduceWaitingTaskChannel</span><br><span class="line">    <span class="keyword">if</span> reduceTask != <span class="literal">nil</span> &#123;</span><br><span class="line">        reduceTask.setTime()</span><br><span class="line">        reduceRunningTaskChannel &lt;- reduceTask</span><br><span class="line">        *reply = reduceTask.GenerateTaskInfo()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.mapRunningTaskChannel) &gt; <span class="number">0</span> || <span class="built_in">len</span>(this.reduceRunningTaskChannel) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        reply.State = <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    replr.State = <span class="number">3</span></span><br><span class="line">    this.isDone = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Master)</span> <span class="title">TaskDone</span><span class="params">(args *TaskInfo, reple *ExampleReply)</span>  <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> args.State &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            mapTask := &lt;- mapRunningTaskChannel</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(this.mapRunningTaskChannel) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(this.mapWaitingTaskChannel) == <span class="number">0</span> &#123;</span><br><span class="line">                this.distributeReduce()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        	reduceTask := &lt;- reduceRunningTaskChannel</span><br><span class="line">        	<span class="keyword">break</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        	pannic(<span class="string">&quot;task error&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Master)</span> <span class="title">distributeReduce</span><span class="params">()</span></span> &#123;</span><br><span class="line">	reduceTask := ReduceTaskStat&#123;</span><br><span class="line">		TaskStat&#123;</span><br><span class="line">			fileIndex: <span class="number">0</span>,</span><br><span class="line">			outFileIndex: <span class="number">0</span>,</span><br><span class="line">			ReduceNum:   this.ReduceNum,</span><br><span class="line">			fileNum:    <span class="built_in">len</span>(this.filenames),</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> reduceIndex := <span class="number">0</span>; reduceIndex &lt; this.nReduce; reduceIndex++ &#123;</span><br><span class="line">		task := reduceTask</span><br><span class="line">		task.partIndex = reduceIndex</span><br><span class="line">		reduceWaitingTaskChannel &lt;- task</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么到此为止呢，实验的大部分内容我也都写完了，主要思路也是借鉴了<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/260752052%E5%92%8Chttps://zhuanlan.zhihu.com/p/54243727%E4%B8%A4%E7%AF%87%E4%B8%93%E6%A0%8F%E7%9A%84%E6%80%9D%E8%B7%AF%EF%BC%8C%E4%B8%BB%E8%A6%81%E4%B8%8D%E5%90%8C%E7%82%B9%E5%B0%B1%E6%98%AF%E5%9C%A8%E4%BA%8E%E5%9C%A8%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E7%9A%84%E6%97%B6%E5%80%99%E5%88%A9%E7%94%A8%E4%BA%86go%E7%9A%84channel%E7%89%B9%E6%80%A7%EF%BC%8C%E5%85%B6%E4%BD%99%E7%9A%84%E6%80%9D%E8%B7%AF%E9%83%A8%E5%88%86%E9%83%BD%E6%98%AF%E5%BE%88%E7%9B%B8%E4%BC%BC%E7%9A%84%E3%80%82">https://zhuanlan.zhihu.com/p/260752052和https://zhuanlan.zhihu.com/p/54243727两篇专栏的思路，主要不同点就是在于在实现的任务队列的时候利用了go的channel特性，其余的思路部分都是很相似的。</a></p>
<hr>
<p>参考连接：</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/260752052">https://zhuanlan.zhihu.com/p/260752052</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/54243727">https://zhuanlan.zhihu.com/p/54243727</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/31/MIT6-824%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9FLab1-MapReduce/" data-id="ckjh1npas000054ljgecf0qcr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-数据结构-优先级队列-堆" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97-%E5%A0%86/" class="article-date">
  <time datetime="2020-12-30T14:25:13.000Z" itemprop="datePublished">2020-12-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97-%E5%A0%86/">数据结构(优先级队列/堆)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="为什么写这篇博客"><a href="#为什么写这篇博客" class="headerlink" title="为什么写这篇博客"></a>为什么写这篇博客</h2><p>​    首先这是比较基础的数据结构的相应知识，需要重新思考一下堆的结构，插入或者删除一个元素的过程。第二就是校招面试的时候曾经面过TopK问题，当时我用的是Java自带的优先级队列API去实现的，但是写完了面试官说不可以用API，我当时因为以前仅仅看过labuladong的算法笔记，没有进行实操，所以写的时间比较长，并且按照该笔记的写法，堆的大小都是固定好的，超出长度就会抛异常，所以我就顺理成章的挂掉了。因此我在今天做面试复盘的时候决定还是重新写一下基本的堆操作。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>​    一般而言，我们选择实现优先级队列可以有如下的方式：</p>
<p>​    (1) 链表：在表头插入<code>O(1)</code>时间复杂度，删除需要遍历整个链表需要<code>O(N)</code>的时间复杂度。如果考虑有序链表，那么插入一个元素的代价就是<code>O(N)</code>，删除则是<code>O(1)</code>。</p>
<p>​    (2) 二叉查找树：平均的时间复杂度是<code>O(LogN)</code>, 对于插入来讲这个时间复杂度是可以满足的，但是如果删除的元素都是一侧(要么左子树要么右子树)，那么删除操作的时间复杂度就会退化成一条链表，即<code>O(N)</code></p>
<p>​    那么实际中我们用到更多的数据结构就是二叉堆，和二叉查找树一样，他也是类似一棵树，但是不同的是他是一颗完全二叉树，为了更好地理解，我们将其画成如下形式：</p>
<p><img src="/2020/12/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97-%E5%A0%86/..%5Cimages%5C%E4%BA%8C%E5%8F%89%E5%A0%86.jpg"></p>
<p>那这种树我们可以换一种表示方法：就是用数组来进行描述</p>
<p><img src="/2020/12/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97-%E5%A0%86/..%5Cimages%5C%E4%BA%8C%E5%8F%89%E5%A0%86%E6%95%B0%E7%BB%84%E8%A1%A8%E7%A4%BA.jpg"></p>
<p>首先我们结合上面两个图来看，数组中任意一个位置的父节点索引都是<code>当前元素索引/2</code>，而任意一个节点的左孩子和右孩子节点就分别是<code>当前索引*2</code>和<code>当前索引*2+1</code>；其次，可以发现在第二张图中，首位的元素为空，这是为了我们以后进行插入元素的时候方便比较插入的元素和要进行交换的元素。</p>
<h2 id="数据结构实现"><a href="#数据结构实现" class="headerlink" title="数据结构实现"></a>数据结构实现</h2><p>那么谈论完概念以后，我们就需要去实现堆，在这片本章里，我们主要实现的是最小堆，即堆顶的元素是最小的，其余的孩子节点都是比堆顶要大的元素，并且我们还要保证堆是一颗完全二叉树，能够通过插入一个元素或者删除一个最小元素调整堆的结构。</p>
<p>首先就来看具体的类是什么样子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heap</span>&lt;<span class="title">Integer</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;? <span class="title">super</span> <span class="title">Integer</span>&gt;&gt;</span>&#123;</span><br><span class="line">	<span class="comment">//无参构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Heap</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">     </span><br><span class="line">	<span class="comment">//可以指定具体大小的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Heap</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;&#125;</span><br><span class="line">     </span><br><span class="line">	<span class="comment">//如果传入的是Integer数组，转换成堆的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Heap</span><span class="params">(Integer [] items)</span> </span>&#123;&#125;</span><br><span class="line">     </span><br><span class="line">	<span class="comment">//插入堆操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Integer x)</span> </span>&#123;&#125;</span><br><span class="line">     </span><br><span class="line">	<span class="comment">//删除最小元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">deleteMin</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">     </span><br><span class="line">	<span class="comment">//拿到最小元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getMin</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">     </span><br><span class="line">	<span class="comment">//判断当前堆是不是为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">     </span><br><span class="line">	<span class="comment">//将堆置空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeEmpty</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">     </span><br><span class="line">	<span class="comment">//设置默认堆大小为10</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//当前堆大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentSize;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//存储元素的底层数组</span></span><br><span class="line">    <span class="keyword">private</span> Integer[] array;</span><br><span class="line">     </span><br><span class="line">	<span class="comment">//构建一个堆</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">     </span><br><span class="line">	<span class="comment">//元素下潜</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> idx)</span> </span>&#123;&#125;</span><br><span class="line">     </span><br><span class="line">	<span class="comment">//堆扩容</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resizeArray</span><span class="params">(<span class="keyword">int</span> newSize)</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>具体的注释我都写在代码上了，大致也就是这些属性和方法。那么对于一个堆而言最重要的就是一些基本操作：插入、删除，下面我们就一起来看一下这些方法怎么实现。</p>
<h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><p>​    插入的思路是这样的，我们的元素需要被放在堆中合适的位置，那么我们可以从堆的最后面开始进行比较，也就是在堆的最后面的节点创建一个新的节点，然后将新节点和父节点的值进行比较，如果确实是新节点比较小的话，就需要把新节点<strong>“上移”</strong>,同时把父节点转移到原先新节点的位置，那么这个时候就相当于新节点就上了一层“台阶”，接下来的操作就是继续和上一层台阶的父节点再进行比较，直到找到合适的位置。我们可以通过图来理解：</p>
<p><img src="/2020/12/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97-%E5%A0%86/..%5Cimages%5C%E5%A0%86%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C1.jpg"></p>
<p><img src="/2020/12/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97-%E5%A0%86/..%5Cimages%5C%E5%A0%86%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C2.jpg"></p>
<p>这个过程用图片描述的比较清楚了，下面我们给出具体的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment">* 插入操作</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Param</span>：x是要插入的元素</span></span><br><span class="line"><span class="comment">***/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Integer x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//首先判断是不是需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (currentSize == array.length - <span class="number">1</span>) &#123;</span><br><span class="line">        resizeArray(array.length * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//插入操作</span></span><br><span class="line">    <span class="comment">//这一步对应图中所说的新建一个节点，即将currentSize+1</span></span><br><span class="line">    <span class="keyword">int</span> idx = ++currentSize; </span><br><span class="line">    <span class="keyword">for</span> (array[<span class="number">0</span>] = x; x.compareTo(array[idx / <span class="number">2</span>]) &lt; <span class="number">0</span>; idx /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">//这一步就是之前文章说的，要将待插入的元素和父节点循环进行比较，如果x比父节点小，那么就上移，否则就找到了要插入的位置。</span></span><br><span class="line">        array[idx] = array[idx / <span class="number">2</span>];<span class="comment">//先把父节点copy下来</span></span><br><span class="line">    &#125;</span><br><span class="line">    array[idx] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于代码里为什么不在循环内做x新节点和父节点的交换操作，书📕<em>Data Structures and Algorithm Analysis in Java</em>中提到如果元素上浮d层，其中每次循环中就有三次赋值交换，总共就是3d次交换，而上面代码的写法就仅仅交换了d+1次，提升了效率。</p>
<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>首先拿到堆的最小元素的操作很简单，就是数组index=1位置的元素值，问题是如果删除了最小的元素，整个堆要怎么进行调整。</p>
<p>删除了堆顶元素之后相当于，堆顶节点空了，所以我们一般来说就要找到一个节点，然后放到这个堆顶的空位置，然后依次向下层重复这个操作。我们一般都是选择将空节点的两个孩子节点中比较小的那个转移到原来堆顶的位置，那么转移过后，原来的那个较小的孩子节点的位置又有变成了空节点“堆顶”，然后一直<strong>“下潜”</strong>就可以了。</p>
<p>我们还是通过图来说明这个过程：</p>
<p><img src="/2020/12/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97-%E5%A0%86/..%5Cimages%5C%E5%A0%86%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C1.jpg"></p>
<p><img src="/2020/12/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97-%E5%A0%86/..%5Cimages%5C%E5%A0%86%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C2.jpg"></p>
<p>书📕<em>Data Structures and Algorithm Analysis in Java</em>中还提到，堆的实践中容易发生错误的情况就是堆中元素个数为偶数时，就会产生一个节点可能只有一个孩子，那么解决的办法就是依旧把它当作拥有两个孩子节点进行比较。（这一段我看的是中文版的书，机翻真的不知所云…）</p>
<p>来看代码解释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment">* 删除最小的堆顶元素</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">deleteMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//首先判空，抛异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//拿到最小的元素</span></span><br><span class="line">    Integer min = getMin();</span><br><span class="line">    <span class="comment">//将图中的“31”节点先记录到空节点上</span></span><br><span class="line">    array[<span class="number">1</span>] = array[currentSize--];</span><br><span class="line">    <span class="comment">//sink下移</span></span><br><span class="line">    sink(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment">* 下移</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Param</span>：idx是从哪个索引处开始下移</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//孩子节点的index</span></span><br><span class="line">    <span class="keyword">int</span> childIdx;</span><br><span class="line">    <span class="comment">//保存我们翻上来的“31”到临时节点</span></span><br><span class="line">    Integer tmp = array[idx];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下移操作</span></span><br><span class="line">    <span class="keyword">for</span> (; idx * <span class="number">2</span> &lt;= currentSize; idx = child) &#123;</span><br><span class="line">        <span class="keyword">if</span> (child != currentSize &amp;&amp; </span><br><span class="line">           array[child + <span class="number">1</span>].compareTo(array[child]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//这一步就是比较左右孩子节点谁更小</span></span><br><span class="line">            child++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (array[child].compareTo(array[tmp]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果左右孩子中小的那个比“31”小，就把孩子节点放到堆顶</span></span><br><span class="line">            array[idx] = array[child];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//&quot;31&quot;找到了位置</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    array[idx] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="扩容操作"><a href="#扩容操作" class="headerlink" title="扩容操作"></a>扩容操作</h3><p>其实没啥说的，但是我面试的时候就没写这个，所以…挂了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resizeArray</span><span class="params">(<span class="keyword">int</span> newSize)</span> </span>&#123;</span><br><span class="line">        Integer[] oldArray = array;</span><br><span class="line">        array = (Integer[]) <span class="keyword">new</span> Comparable[newSize];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldArray.length; i++) &#123;</span><br><span class="line">            array[i] = oldArray[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="构建堆操作"><a href="#构建堆操作" class="headerlink" title="构建堆操作"></a>构建堆操作</h3><p>这一步我们重点对如果传入的是一个数组进行堆化的操作，一般来说可以将长度为N的数组用任意的顺序放到我们的二叉堆中，然后进行sink操作就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Heap</span><span class="params">(Integer[] items)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调整堆的大小</span></span><br><span class="line">    currentSize = items.length;</span><br><span class="line">    </span><br><span class="line">    array = (Integer[])<span class="keyword">new</span> Comparable((currentSize + <span class="number">2</span>) * <span class="number">11</span> / <span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//写到底层数组里</span></span><br><span class="line">    <span class="keyword">for</span> (Integer num : items) &#123;</span><br><span class="line">        array[i++] = num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//堆化</span></span><br><span class="line">    buildHeap();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = currentSize / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        sink(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    堆的基本操作基本都涵盖到了，但是还有一些细枝末节的部分这篇博文就不涉及了（主要是懒得写了），主要是为了总结一下重点，了解一下堆的各种基本操作。</p>
<hr>
<p>参考文献</p>
<p>1.<em>Data Structures and Algorithm Analysis in Java</em></p>
<p>2.labuladong的算法小抄</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97-%E5%A0%86/" data-id="ckjcahnda00007gljg3yh0gko" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Elasticsearch分布式特性" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/09/Elasticsearch%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%B9%E6%80%A7/" class="article-date">
  <time datetime="2020-12-09T14:07:53.000Z" itemprop="datePublished">2020-12-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/09/Elasticsearch%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%B9%E6%80%A7/">Elasticsearch分布式特性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Elasticsearch分布式特性"><a href="#Elasticsearch分布式特性" class="headerlink" title="Elasticsearch分布式特性"></a>Elasticsearch分布式特性</h1><p><em>上一篇文章我们简要的了解了ES的一些基本概念，比如说什么是索引，文档以及分片、分段和它们的多少对于集群的一些影响，但是介绍的还不够深入，那么这篇文章就是进一步展示ES的分布式的一些特性和部分配置。</em></p>
<p><em>上一篇文章(Elasticsearch基本概念和原理)的链接：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6904073645757792264">https://juejin.cn/post/6904073645757792264</a></em></p>
<h2 id="ES的分布式架构有什么好处？"><a href="#ES的分布式架构有什么好处？" class="headerlink" title="ES的分布式架构有什么好处？"></a>ES的分布式架构有什么好处？</h2><ul>
<li>存储的水平扩容，能够支持PB级数据</li>
<li>提高系统的可用性（某些节点如果挂掉，对于整个集群没有太大影响）</li>
</ul>
<blockquote>
<p>分布式架构</p>
</blockquote>
<p>不同的集群通过不同的名字来区分，默认是<code>elasticsearch</code>,具体的名字我们可以通过配置文件进行修改，或者在命令行里用<code>-E cluster.name = Duters </code>进行设定。</p>
<p>此外，每一个Node节点就是一个ElasticSearch实例，也就是一个Java进程，一般生产环境下一台机器就运行一个ES实例，每个节点启动之后都会分配一个UID，保存在data目录下面。</p>
<blockquote>
<p>Coordinating Node</p>
</blockquote>
<p>处理请求的节点就叫做Coordinating Node</p>
<ul>
<li><p>从上篇文章我们能看到创建Index的时候，我们只提到了请求会被打到一个节点上，但是这个节点（Coordinating Node）是需要通过路由打到Master节点上的。</p>
</li>
<li><p>所有节点默认都是Coordinating Node</p>
</li>
<li><p>通过设置其他类型为False，我们可以使节点变成Dedicated Coordinating Node</p>
</li>
</ul>
<p>我们可以通过Cerebro查看相应的集群状态和节点分片信息：</p>
<p><img src="/2020/12/09/Elasticsearch%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%B9%E6%80%A7/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201209104502047.png" alt="image-20201209104502047"></p>
<blockquote>
<p>Data Node与Master Node</p>
</blockquote>
<p>保存数据的节点，并且保存的是分片的数据，在数据扩展上起到了关键的作用，也就是说是由Master节点来决定怎样把数据发送到数据节点上，增加数据节点可以解决数据水平扩展和解决数据单点的问题</p>
<ul>
<li><p>节点启动后默认就是数据节点，可以设置<code>node.data:false</code>来禁止</p>
</li>
<li><p>Master Node负责创建、删除index/决定分片被分配到哪个节点</p>
</li>
<li><p>维护和更新cluster State</p>
</li>
<li><p>实践：master节点很重要，要考虑单点问题，一个集群最好有多个master节点/每个节点只承担master的单一角色</p>
</li>
<li><p>如果说其中一个master节点出现了故障，那么就要有选举流程选出一个master节点，每个节点启动后默认是一个master eligible节点（配置<code>node.master：false</code>来禁止）</p>
</li>
<li><p>集群内的第一个master eligible节点启动的时候默认是把自己选举成master节点</p>
</li>
<li><p>集群状态：节点信息，所有的索引和相关的mapping和setting信息，分片的路由信息，每个节点上都保存了集群的状态信息，但是只有master节点能修改信息，并且负责同步给其他节点，</p>
</li>
</ul>
<blockquote>
<p>选举过程</p>
</blockquote>
<p>1.互相ping对方，Node id小的会被选举成master节点</p>
<ul>
<li><p>寻找 clusterStateVersion 比自己高的 master eligible 的节点，向其发送选票</p>
</li>
<li><p>如果 clusterStatrVersion 一样，则计算自己能找到的 master eligible 节点（包括自己）中节点 id 最小的一个节点，向该节点发送选举投票</p>
</li>
<li><p>如果一个节点收到足够多的投票（即 <code>minimum_master_nodes</code> 的设置），并且它也向自己投票了，那么该节点成为 master 开始发布集群状态</p>
</li>
</ul>
<p>2.其他节点加入集群后，不承担master节点的角色，如果发现被选中的master节点挂掉了，再重新选举</p>
<p>![](F:\YoungLH’s blog\source\images\master节点选举流程概览.jpg)</p>
<p><strong>怎么触发一次选举？</strong></p>
<ul>
<li>当前的master eligible节点不是master</li>
<li>节点之间做网络通信</li>
<li>集群中无法连接到 master 的 master eligible 节点数量已达到 <code>discovery.zen.minimum_master_nodes</code> 所设定的值</li>
</ul>
<p><strong>脑裂问题</strong>：分布式系统的经典网络问题，当出现网络问题的时候，一个节点和其他节点无法进行通信，</p>
<p>![](F:\YoungLH’s blog\source\images\脑裂问题.jpg)</p>
<p>如上图所示，Node2和Node3会重新选举Master节点，而Node1自己作为master组成一个集群，同时更新了cluster state，这就导致了产生两个master节点，并且有两个集群状态，网络一旦恢复了，就没有办法正确恢复。</p>
<p><strong>怎么避免脑裂？</strong></p>
<p>限定一个选举条件，设置Quorum仲裁，只有Master eligible节点数大于quorum时，才能进行选举</p>
<ul>
<li><p>Quorum = （master节点总数/2）+1</p>
</li>
<li><p>当三个master eligible 时，设置discovery.zen.minimum_master_nodes为2，就可以避免脑裂</p>
</li>
<li><p>7.0以后的版本不需要配置了</p>
</li>
</ul>
<h2 id="分片的若干问题"><a href="#分片的若干问题" class="headerlink" title="分片的若干问题"></a>分片的若干问题</h2><blockquote>
<p>从上一篇文章我们知道，文档会存储在具体的某个主分片和副本分片上，但是怎么决定这个文档存储到哪个分片上呢？</p>
</blockquote>
<h3 id="映射算法"><a href="#映射算法" class="headerlink" title="映射算法"></a>映射算法</h3><ul>
<li><p>确保文档能均匀的分布在所用的分片上，充分利用硬件资源，从而避免部分机器空闲，部分机器繁忙。</p>
</li>
<li><p>潜在的算法：</p>
<ul>
<li>随机/Round Robin：当查询文档1的时候，如果说分片数很多，可能就需要多次查询才有可能查到文档1。</li>
<li>维护一个文档到分片的映射关系。那么当文档数据量大的时候，维护的成本也很高。</li>
<li>实时计算，通过文档1，自动算出一个值，从而去该值对应的分片上获取文档。</li>
</ul>
<p>ES是怎么路由的呢？</p>
<ul>
<li><p>公式：<code>shard = hash(_routing) % number_of_primary_shards</code></p>
<p>1.Hash算法确保了文档均匀分散。</p>
<p>2.默认的_routing值是文档id。</p>
<p>3.可以自行指定_routing数值。</p>
<p>4.这也是设置了Index Settings后，Primary数就不能随意更改的原因。</p>
</li>
</ul>
</li>
</ul>
<h3 id="倒排索引的不可变性"><a href="#倒排索引的不可变性" class="headerlink" title="倒排索引的不可变性"></a>倒排索引的不可变性</h3><p>此外，我们再创建一个Index的时候会生成倒排索引，倒排索引是不可变的，一旦生成就不能再更改。</p>
<p>这带来的好处有：</p>
<ul>
<li>无需考虑并发写文件的问题，避免了锁机制带来的性能问题</li>
<li>一旦读入内核的文件系统缓存，便留在那里，只要文件系统有足够的空间，大部分请求就会直接去请求内存，不会命中磁盘，提升了很大的性能</li>
<li>缓存容易生成和维护，数据也可以被压缩</li>
</ul>
<p>但是这也带来了挑战：如果需要让一个新的文档可以被搜索就需要重建索引。</p>
<p>那么在Lucene Index中是包含很多的分段的，而分段也被就是单个倒排索引，多个segment汇总在一起就组成了相应的分片</p>
<p>![](F:\YoungLH’s blog\source\images\分片的构造.jpg)</p>
<h3 id="文档的写入和删除具体流程"><a href="#文档的写入和删除具体流程" class="headerlink" title="文档的写入和删除具体流程"></a>文档的写入和删除具体流程</h3><p>那么我们知道了相应的分片路由公式之后，具体我们想写入一个文档的流程是怎么样的呢？在前一篇我们仅仅从宏观上阐述了过程，下面在我们来看一下相对详细一点的过程：</p>
<p>![](F:\YoungLH’s blog\source\images\更新index的详细过程.jpg)</p>
<p>在进行写操作时，因为任意一个节点都是coordinating Node，因此请求达到了一个节点上都可以进行处理，那么ES会根据传入的_routing参数（或mapping中设置的_routing, 如果参数和设置中都没有则默认使用_id), 按照公式 <code>shard_num=hash(\routing)%num_primary_shards</code>,计算出文档要分配到的分片，在从集群元数据中找出对应<strong>主分片</strong>的位置，将请求路由到该分片进行文档写操作，此外还需要并发的写入到副本分片中从而完成一次写入。</p>
<ul>
<li><p>那么问题来了，一个文档被写入了以后能够被立刻查询到吗？</p>
<p><em>回忆一下我们上一篇文章中说的，分段关闭了才能被查询，关闭的过程叫做refresh刷新</em></p>
<p>答案是可以的，这也是为什么ES是近实时性的体现，首先我们知道ES的每一个分片都是一个Lucene索引，ES提供了一个refresh操作，首先再Index一个文档的时候，ES会先把docunment写入到index buffer中（内存里的），然后他会定时的调用lucene的reopen（新版本是openIfChanged）给内存中新写入的数据生成一个分段segment，此时被处理的文档均可以被检索到，refresh的时间间隔由 <code>refresh_interval</code>参数控制，默认为1s, 当然还可以在写入请求中带上refresh表示写入后立即refresh，另外还可以调用refresh API显式refresh。</p>
</li>
<li><p>第二个问题，那么数据怎么保证存储可靠性呢？</p>
<p>我们知道我们虽然在前面写入了数据，但是此时的数据是存储在内存中的，那么如果说这个时候ES服务器宕机了，那么这部分数据就会丢失，为了解决这个问题，ES引入了<code>translog</code>:当我们进行文档的写入操作时，会先将文档写入到Lucene的分段中，然后再写一份到<code>translog</code>中，写入<code>translog</code>是落盘的(如果对可靠性要求不是很高，也可以设置异步落盘，可以提高性能，由配置 <code>index.translog.durability</code>和 <code>index.translog.sync_interval</code>控制)，这样就可以防止服务器宕机后数据的丢失。由于<code>translog</code>是追加写入，因此性能要比随机写入要好。与传统的分布式系统不同，这里是先写入Lucene再写入<code>translog</code>，原因是写入Lucene可能会失败，为了减少写入失败回滚的复杂度（ES是不支持事务的），因此先写入Lucene。</p>
</li>
<li><p>第三个问题，<code>translog</code>是落盘的，那么什么时候落盘呢？频率是什么样子？</p>
<p>这就涉及到flush操作，每30分钟或当<code>translog</code>达到一定大小(由 <code>index.translog.flush_threshold_size</code>控制，默认512mb), ES会触发一次flush操作，此时ES会先执行refresh操作将index buffer中的数据生成segment，然后调用lucene的commit方法将所有内存中的segment fsync到磁盘。此时lucene中的数据就完成了持久化，会清空<code>translog</code>中的数据(6.x版本为了实现sequenceIDs,不删除<code>translog</code>)</p>
<p>![](F:\YoungLH’s blog\source\images\写入过程flush的全局图.jpg)</p>
</li>
</ul>
<p>除了上面的flush过程，我们在第一篇文章中也说到过，分段大小超过一定阈值会进行合并吗，具体过程就是：</p>
<ol>
<li><strong>merge操作</strong> 由于refresh默认间隔为1s，因此在这个过程中不断地写入打开的分段就会产生大量的小segment，为此ES会运行一个任务检测当前磁盘中的segment，对符合条件的segment进行合并操作，减少lucene中的segment个数，提高查询速度，降低负载。不仅如此，merge过程也是文档删除和更新操作后，旧的doc真正被删除的时候。用户还可以手动调用_forcemerge API（<code>POST my_index/__forcemerge</code>）来主动触发merge，以减少集群的segment个数和清理已删除或更新的文档。</li>
<li><strong>多副本机制</strong> 另外ES有多副本机制，一个分片的主副分片不能分片在同一个节点上，进一步保证数据的可靠性。</li>
</ol>
<p>分片的写入说完了，同理，删除一个文档也同样，具体就不再赘述了：</p>
<p>![](F:\YoungLH’s blog\source\images\删除的详细过程.jpg)</p>
<h2 id="分布式搜索的运行机制"><a href="#分布式搜索的运行机制" class="headerlink" title="分布式搜索的运行机制"></a>分布式搜索的运行机制</h2><p>ES的搜索分成两部分</p>
<ul>
<li><p>第一阶段是Query</p>
</li>
<li><p>第二阶段是Fetch</p>
<p>具体流程是：</p>
<ul>
<li><p>用户发出搜索请求到ES节点，节点收到请求后会以Coordinating Node的身份，在6个主副节点中随机选择三个分片发送查询请求。</p>
</li>
<li><p>被选中的分片执行查询，<strong>进行排序</strong>，然后每个分片都会返回From+Size个排序后的文档id和排序值给Coordinating Node。</p>
<p>![](F:\YoungLH’s blog\source\images\搜索详细过程.jpg)</p>
</li>
<li><p>Fetch阶段Coordinating Node会把query阶段首先拿到从每个获取的排序后的文档id列表进行重新排序，选取From到From+Size的文档id。</p>
</li>
<li><p>用multi_get请求的方式到相应的分片获取详细的文档数据</p>
</li>
</ul>
<p>问题：</p>
<ul>
<li><p>性能问题：</p>
<ul>
<li>每个分片都需要查的文档个数=from+size</li>
<li>最终Coordinating Node需要处理：number of shards * （from + size）这么多数据</li>
<li>深度分页，这也是搜索引擎一直存在的问题（ES可以试用search after的api）</li>
</ul>
</li>
<li><p>相关性算分问题</p>
<ul>
<li>每个分片都是基于自己分片上的数据进行相关度计算，这会导致score的偏离</li>
</ul>
<p>怎么解决相关性算分问题？</p>
<ul>
<li><p>当数据量不大的时候可以设置主分片数量为1</p>
</li>
<li><p>数据量足够大的时候，只要保证文档均匀分散在哥哥分片上，结果就不会出现太大偏差</p>
</li>
<li><p>可以试用DFS Query Then Fetch：搜索URL中添加</p>
<p><code>_search?search_type=dfs_query_then_fetch</code>参数,原理是到每个分片上把各个分片的词频和文档频率进行搜集，然后完整的进行一次相关度算分，但是这种情况会消耗更多的CPU和内存，执行性能不好。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="ES并发控制"><a href="#ES并发控制" class="headerlink" title="ES并发控制"></a>ES并发控制</h2><p>看一个例子：</p>
<p>![](F:\YoungLH’s blog\source\images\ES并发问题.jpg)</p>
<p>为什么第二个线程扣完了库存以后库存量还是99呢？</p>
<p>首先数据库的锁包含悲观锁和乐观锁</p>
<p>ES采用的是乐观并发控制的思想，假定不会发生冲突，不会阻塞正在尝试的操作，如果数据在读写的过程中被修改了，更新就会失败。ES会将怎么解决冲突交给我们编写的应用程序来实现，比如我们可以做失败重试，或者提交错误报告等等。</p>
<ul>
<li><p>ES提供了_seq_no和__primary_term这两个字段，我们可以去用这两个字段在程序里做判断从而实现版本控制</p>
<p>比如上一次查询结果我们拿到的_seq_no和primary_term分别是0和1，那么下次更新的时候我们的QSL语句可以这么写：        </p>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT my_idx/_doc/1?if_seq_no=0&amp;if_primary_term=1</span><br><span class="line">&#123;</span><br><span class="line">	<span class="attr">&quot;title&quot;</span>:<span class="string">&quot;DaLian University of Technology&quot;</span></span><br><span class="line">	<span class="string">&quot;department&quot;</span> : <span class="string">&quot;Control Science and engineering&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果我们现在的情况是ES的数据是从类似MySQL同步过来的，纳闷我们还可以利用版本号MySQL中的version和ES中的version_type进行比较从而进行并发控制。</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT my_idx/_doc/1?version=100000&amp;version_type=external</span><br><span class="line">&#123;</span><br><span class="line">	<span class="attr">&quot;title&quot;</span>:<span class="string">&quot;DaLian University of Technology&quot;</span></span><br><span class="line">	<span class="string">&quot;department&quot;</span> : <span class="string">&quot;Control Science and engineering&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<p>参考链接</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.nosuchfield.com/2019/03/18/How-Elasticsearch-elected-the-master/">https://www.nosuchfield.com/2019/03/18/How-Elasticsearch-elected-the-master/</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/94915597">https://zhuanlan.zhihu.com/p/94915597</a></li>
<li>极客时间-ElasticSearch核心技术与实战（阮一鸣）</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/09/Elasticsearch%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%B9%E6%80%A7/" data-id="ckihhnblr0000iwljbj4t9vu5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ElasticSearch基本概念与原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/24/ElasticSearch%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%8E%9F%E7%90%86/" class="article-date">
  <time datetime="2020-11-24T15:28:29.000Z" itemprop="datePublished">2020-11-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/24/ElasticSearch%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%8E%9F%E7%90%86/">ElasticSearch基本概念与原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="ElasticSearch基本介绍"><a href="#ElasticSearch基本介绍" class="headerlink" title="ElasticSearch基本介绍"></a>ElasticSearch基本介绍</h2><ul>
<li><p>ES是什么？</p>
<p>ES是一款基于Apache Lucene的开源分布式搜索引擎</p>
</li>
<li><p>应用场景</p>
<ul>
<li>日志记录与分析（接口调用情况）</li>
<li>采集和组合公共数据（用户行为、点击事件）</li>
<li>全文检索</li>
<li>数据可视化（通过Kibana）</li>
</ul>
</li>
<li><p>逻辑与物理设计</p>
<p>首先看一些概念：</p>
<ul>
<li><p>集群cluster</p>
<p>ES是分布式的，多个节点构成一个集群，并且集群也是可扩展的</p>
</li>
<li><p>节点node</p>
<p>每个启动的ES实例就是一个节点，可以随时加入或者脱离集群</p>
</li>
<li><p>索引index</p>
<p>名词：一堆字段相似的文档的集合，类比MySQL的一张表</p>
<p>动词：将文档写入某个索引</p>
</li>
<li><p>文档document</p>
<p>一条ES的记录，类比MySQL的一行数据</p>
</li>
<li><p>分片shard</p>
<ul>
<li>分片是ES所能管理的最小单元</li>
<li>一个分片就是一个Lucenne索引</li>
<li>一个包含倒排索引的文件目录</li>
<li>分片越多（过度分片），搜索有可能越慢</li>
</ul>
</li>
<li><p>分段segment</p>
<ul>
<li><p>lucene索引再分割的小单元</p>
</li>
<li><p>分段不会被修改</p>
</li>
<li><p>分段越多，搜索越慢</p>
</li>
<li><p>索引新的文档会创建新的分段</p>
</li>
<li><p>分段会被持续地合并</p>
</li>
<li><p>删除文档的时候不会真的删除（只是设置了标记）</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>分片：扩展与容灾</p>
</blockquote>
<p><img src="../images/ES%E6%A6%82%E5%BF%B5%E5%9B%BE.jpg"></p>
<p>首先，一个索引地所有分片会自动均匀地分布在所有节点中。当我们加入一个新节点后，如下图所示，原集群节点中地分片，有部分会迁移到新节点。</p>
<p><img src="../images/%E5%8A%A0%E5%85%A5%E8%8A%82%E7%82%B9.jpg"></p>
<p><em>注：设置分片数量稍微大于节点数量，有利于横向扩容时，分片蔓延到所有新节点，如图一所示，就是一个index包含四个分片，而es集群中有三个节点，新加入节点后可以蔓延（最理想的状态就是每个节点都有分片）。但是蔓延的过程是有一定消耗的，所以会对集群产生一些抖动的。此外，当主分片和所有副本分片都就绪时，索引地健康状态是绿色</em></p>
<p>我们在Kibana的monitoring组件上可以看见分片的活跃程度。</p>
<p>接下来我们来分析容灾，如下图所示为在图1的基础上挂掉一个节点的示意图。</p>
<p><img src="../images/%E6%8C%82%E6%8E%89%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9.jpg"></p>
<ul>
<li>当挂掉了N个节点时，如果副本分片是N，那么剩下的副本分片将  自动提升为主分片。</li>
<li>然后所有的主分片能构成完整的索引，但是副本分片缺失时，此时索引健康状态是黄色。</li>
<li>如果挂掉N+1个节点，主分片将缺失，健康状态是红色。</li>
<li>我们需要根据实际情况合理的设置副本的数量（副本太多也会影响性能）</li>
<li>通常同时挂掉两个节点的概率不高，一般来说一个副本可以满足常规容灾要求。</li>
</ul>
<blockquote>
<p>索引和搜索数据</p>
</blockquote>
<p>索引请求如下图所示：</p>
<p><img src="../images/%E7%B4%A2%E5%BC%95%E8%AF%B7%E6%B1%82.jpg"></p>
<ul>
<li><p>具体过程</p>
<ul>
<li>索引文档请求到一个节点</li>
<li>文档会被随机到一个主分片上</li>
<li>从主分片同步到副本分片</li>
<li>返回成功的结果</li>
</ul>
<p>注：副本分片越多，索引数据越慢，因为要所有副本都完成才算成功</p>
</li>
</ul>
<p>再来看搜索过程，如下图所示：</p>
<p><img src="../images/%E6%90%9C%E7%B4%A2%E8%AF%B7%E6%B1%82.jpg"></p>
<ul>
<li><p>具体过程</p>
<ul>
<li>搜索请求到一个节点</li>
<li>节点转发请求到本节点的一个分片和其他节点的另一个分片</li>
<li>所有的分片都返回搜索结果到起始节点，但是只要有一个shard搜索到了数据就会立刻返回</li>
<li>起始节点返回搜索结果到请求方</li>
</ul>
<p>注：不同节点的主分片+副本分片的总数越多，请求被分摊的越  多，并发搜索兴能越好。但是如果节点数很少，分片都集中到了少数节点上，搜索速度会变慢，因为增加了开销，实际没有分摊负载。此外，单个搜索没有办法通过分片加速。</p>
</li>
</ul>
<blockquote>
<p>分段</p>
</blockquote>
<p><img src="../images/%E5%88%86%E6%AE%B5.jpg"></p>
<ul>
<li><p>写入</p>
<ul>
<li>只能写打开的分段（为了避免冲入合并）</li>
<li>删除是假的删除，也是往打开的分段里写标志位（这是为了保证随机读写）</li>
<li>分段大小超过一定阈值，会触发分段合并</li>
<li>小分段合并成大分段，为了查询加速，但合并过程是先创建一个大分段，再把两个小的放进去，再删除这两个小的，但这个过程会耗费大量资源</li>
<li>如果希望写入快，就要避免频繁的分段合并</li>
</ul>
</li>
<li><p>读取</p>
<ul>
<li>只能读取关闭的分段（所以ES叫准实时，关闭这个过程也叫做刷新）</li>
<li>对一个分片查询，会等它所有的分段返回结果，所以分段过多，查询越慢</li>
<li>刷新时，会关闭一批分段，这时候数据才能被查到</li>
<li>刷新频率太快会导致分段碎片多</li>
<li>刷新频率过慢会导致实时性低</li>
</ul>
</li>
</ul>
<p><em>总结一下，我们可以看到，如果我们追求的是写入更快的话，我们就要尽力的避免频繁的分段合并，保留相对多一点的分段；但是如果我们要追求读取性能的话又要考虑减少分段，这也就是鱼和熊掌的问题了，需要我们结合实际业务场景进行分析。</em></p>
<p>Kibana中的一些设置：</p>
<p><img src="../images/kibana%E8%AE%BE%E7%BD%AE.jpg"></p>
<p>在Kibana中我们可以设置刷新的频率、副本数量等等参数</p>
<ul>
<li><p>那么索引分片不是免费的吗/分片越多越好吗？</p>
<ul>
<li><p>每个索引和分片都会产生一定的资源开销，尤其是内存资源</p>
</li>
<li><p>每个索引，映射和状态的信息都存储在集群中</p>
<ul>
<li>存储在内存中，以便快速访问</li>
<li>分片数量过多，会导致集群状态过大</li>
<li>这会导致更新变慢，因为所有的更新都是通过单线程来完成的，从而这是在将变更分发到整个集群之前确保一致性的前提</li>
</ul>
</li>
<li><p>分片有一部分数据需要保存在内存中</p>
<ul>
<li>这部分数据也会占据堆内存空间</li>
<li>这包括存储分片级别以及段级别信息的数据结构</li>
<li>因为只有这样才能确定数据在磁盘上的存储位置</li>
</ul>
</li>
<li><p>那怎么样在单个节点上存储尽可能多的数据呢？</p>
<ul>
<li>管理堆内存使用量</li>
<li>尽可能减少开销</li>
<li>节点的堆内存空间越多，能处理的数据和分片就越多</li>
<li>官方建议：JVM heap每1G不超过20个分片，每个分片大小在20G</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<p><em>参考连接</em></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1kf4y1R7qR">https://www.bilibili.com/video/BV1kf4y1R7qR</a></li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/">https://www.elastic.co/guide/en/elasticsearch/reference/</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/24/ElasticSearch%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%8E%9F%E7%90%86/" data-id="ckhw55q7x000024ljc3l77h51" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-算法-二分法-一" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/16/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%B3%95-%E4%B8%80/" class="article-date">
  <time datetime="2020-11-16T06:43:08.000Z" itemprop="datePublished">2020-11-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/16/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%B3%95-%E4%B8%80/">算法-二分法(一)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="二分查找的模板"><a href="#二分查找的模板" class="headerlink" title="二分查找的模板"></a>二分查找的模板</h3><p>二分查找有很多种写法，以下是参考了网络资料后(LeetCode官方算法书)得到的二分的几种基本写法，具体参考链接将放在文章尾部。某些题目的思路中是依照自己的想法来实现的，如有错误请指正，谢谢！</p>
<h4 id="第一种写法"><a href="#第一种写法" class="headerlink" title="第一种写法"></a>第一种写法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种模板是二分查找最基础和最基本的形式，它有三种关键的属性</p>
<ul>
<li>二分查找的最基本的形式</li>
<li>查找条件可以在不与元素的两侧进行比较的时候使用</li>
<li>不需要后处理，因为在每一步中，你都在检查是否找到了元素。如果到达末尾，则知道未找到该元素。</li>
</ul>
<p><strong>例题</strong></p>
<blockquote>
<p>LeetCode69题 - x的平方根</p>
</blockquote>
<p>实现<code> int sqrt(int x)</code>函数，计算并返回x的平方根，其中x是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分舍去。</p>
<p>示例1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：4</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p>示例2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：8</span><br><span class="line">输出：2</span><br><span class="line">说明: 8 的平方根是 2.82842..., </span><br><span class="line">     由于返回类型是整数，小数部分将被舍去。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解题思路</p>
</blockquote>
<p>首先这道题是算x的平方根，那么二分的话左边界就是1，右边界就是x，循环的过程中计算mid的值，并判断mid*mid和x的大小，如果相等就说明找到了，不相等需要对左右边界做调整。并且在循环过程中要有一个变量ans来记录当前的而二分结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = x;</span><br><span class="line">        <span class="keyword">long</span> ans = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">long</span>)mid * mid &lt;= x) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                left = mid  + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>LeetCode374 - 猜数字的大小</p>
</blockquote>
<p>猜数字游戏的规则如下：</p>
<ul>
<li>每轮游戏，系统都会从 1 到 n 随机选择一个数字。 请你猜选出的是哪个数字。</li>
<li>如果你猜错了，系统会告诉你，你猜测的数字比系统选出的数字是大了还是小了。</li>
</ul>
<p>你可以通过调用一个预先定义好的接口 <code>guess(int num)</code> 来获取猜测结果，返回值一共有 3 种可能的情况<code>（-1，1 或 0）</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-1 : 你猜测的数字比系统选出的数字大</span><br><span class="line"> 1 : 你猜测的数字比系统选出的数字小</span><br><span class="line"> 0 : 恭喜！你猜对了！</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n &#x3D; 10, pick &#x3D; 6</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解题思路</p>
</blockquote>
<p>这道题应该是本科的时候学c语言写的的一个程序了，总体思路就是猜的数大了就把右边界调整一下，小了调整左边界，就直接写代码了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">GuessGame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">guessNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = n;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> res = guess(mid);</span><br><span class="line">            <span class="keyword">if</span> (res == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res == -<span class="number">1</span>) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//时间复杂度：O(logN)</span></span><br><span class="line"><span class="comment">//空间复杂度: O(1)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>LeetCode33 - 搜索旋转排序数组</p>
</blockquote>
<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2] </code>)</p>
<p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p>
<p>你可以假设数组中不存在重复的元素。</p>
<p>你的算法时间复杂度必须是 <code>O(logN) </code>级别。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0</span><br><span class="line">输出: 4</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解题思路</p>
</blockquote>
<p>这道题是一道面试中比较喜欢考的问题，也是一道比较有意思的问题，首先的问题就是旋转的排序数组是什么，不妨可以按照如下图所示来进行理解</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201001153032710.png" alt="image-20201001153032710"></p>
<p>这样的话可以发现，转折点将排序数组分成了两段，在<code>[0,1,2,4,5,6,7]</code>这个例子里两段线没有重复，那么接下来我们就需要去实现查找，具体的步骤如下：</p>
<ul>
<li>首先我们计算出中点的<strong>索引</strong>mid</li>
<li>第二步我们要去判断<code>nums[mid]</code>和target的大小<ul>
<li>如果说正好相等，那么就证明找到了，返回mid即可</li>
<li>如果不相等，这时候就需要考虑mid是在左边的线段上还是右边的线段上，因为二分查找一般只能用于有序的数组上<ul>
<li>如果mid在左边的线段上(判断条件就是<code>nums[mid] &gt;= nums[0])</code>,并且还要和target比较，如果这个时候target正好处在<code>nums[left]</code>和<code>nums[mid]</code>中间的话，那么就调整<code>right = mid - 1</code>；否则调整<code>left = mid + 1</code></li>
<li>如果mid在右边的线段上，如果target正好在<code>nums[mid]</code>和<code>nums[n - 1]</code>中间，那么调整<code>left = mid + 1</code>;否则调整<code>right = mid - 1</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>OK,到了这一步思路基本就捋清楚了，下面给出代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="comment">//边界case</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> target == nums[<span class="number">0</span>] ? <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//二分</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= nums[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt;= target &amp;&amp; target &lt;= nums[mid]) &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[n - <span class="number">1</span>] &gt;= target &amp;&amp; nums[mid] &lt;= target) &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//时间复杂度：O(logN)  N为数组长度</span></span><br><span class="line"><span class="comment">//空间复杂度：O(1)</span></span><br></pre></td></tr></table></figure>



<h4 id="第二种写法"><a href="#第二种写法" class="headerlink" title="第二种写法"></a>第二种写法</h4><p>第二种写法主要是在判断条件和后置处理上做出了一些改变，主要使用的情况包括查找需要<em>访问数组中当前索引及其直接右邻居索引</em>的元素或条件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length;</span><br><span class="line">  <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">    <span class="comment">// Prevent (left + right) overflow</span></span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target) &#123; </span><br><span class="line">            <span class="keyword">return</span> mid; </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123; </span><br><span class="line">            left = mid + <span class="number">1</span>; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            right = mid; </span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Post-processing:</span></span><br><span class="line">  <span class="comment">// End Condition: left == right</span></span><br><span class="line">  <span class="keyword">if</span>(left != nums.length &amp;&amp; nums[left] == target) <span class="keyword">return</span> left;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>关键属性<ul>
<li>一种实现二分查找的高级方法。</li>
<li>查找条件需要访问元素的直接右邻居。</li>
<li>使用元素的右邻居来确定是否满足条件，并决定是向左还是向右。</li>
<li>保证查找空间在每一步中至少有 2 个元素。</li>
<li>需要进行后处理。 当你剩下 1 个元素时，循环 / 递归结束。 需要评估剩余元素是否符合条件。</li>
</ul>
</li>
</ul>
<p><strong>例题</strong></p>
<blockquote>
<p>LeetCode278 - 第一个错误的版本</p>
</blockquote>
<p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p>
<p>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。</p>
<p>你可以通过调用 <code>bool isBadVersion(version)</code> 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定 n &#x3D; 5，并且 version &#x3D; 4 是第一个错误的版本。</span><br><span class="line"></span><br><span class="line">调用 isBadVersion(3) -&gt; false</span><br><span class="line">调用 isBadVersion(5) -&gt; true</span><br><span class="line">调用 isBadVersion(4) -&gt; true</span><br><span class="line"></span><br><span class="line">所以，4 是第一个错误的版本。 </span><br></pre></td></tr></table></figure>

<blockquote>
<p>解题思路</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">VersionControl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = n;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (isBadVersion(mid)) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>LeetCode162 - 寻找峰值</p>
</blockquote>
<p>峰值元素是指其值大于左右相邻值的元素。</p>
<p>给定一个输入数组 <code>nums</code>，其中 <code>nums[i] ≠ nums[i+1]</code>，找到峰值元素并返回其索引。</p>
<p>数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。</p>
<p>你可以假设 <code>nums[-1] = nums[n] = -∞</code>。</p>
<p>示例1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [1,2,3,1]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 3 是峰值元素，你的函数应该返回其索引 2。</span><br></pre></td></tr></table></figure>

<p>示例2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [1,2,1,3,5,6,4]</span><br><span class="line">输出: 1 或 5 </span><br><span class="line">解释: 你的函数可以返回索引 1，其峰值元素为 2；</span><br><span class="line">     或者返回索引 5， 其峰值元素为 6。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解题思路</p>
</blockquote>
<p>峰值就是两边低中间高，那么我们需要找一个元素，左边的比他小，右边的比他小，由于 <code>nums[-1] = nums[n] = -∞</code>，所以可以用二分，每次都找到中间的mid，看一下他右边的元素是不是比自己小，是的话可能他自己就是峰值，但是还需要向左去看，因此我们可以把right  = mid；这样一旦右边的元素比自己大了，证明峰值就在右边了，left = mid + 1；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>LeetCode153 - 寻找旋转数组中最小的元素</p>
</blockquote>
<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 <code>[0,1,2,4,5,6,7] </code>可能变为<code> [4,5,6,7,0,1,2]</code> )。</p>
<p>请找出其中最小的元素。</p>
<p>你可以假设数组中不存在重复元素。</p>
<p>示例1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,4,5,1,2]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p>示例2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [4,5,6,7,0,1,2]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解题思路</p>
</blockquote>
<p>同样是旋转数组，但是和上面那个找target的题目不一样的地方在于需要去比较mid旁边的数值了，因此不能用模板的第一种写法。</p>
<ul>
<li><p>首先如果数组没有被旋转肯定是最后一个元素比第一个元素大，那么直接返回第一个元素即可</p>
</li>
<li><p>否则如果数组被旋转过了，肯定就存在一个旋转点，这个点的左边部分都大于第一个元素，这个点的右边部分都小于第一个点</p>
<ul>
<li>先找到中间点mid</li>
<li>如果<code>nums[mid] &gt; nums[0]</code>,最小值就在mid右边</li>
<li>如果<code>nums[mid] &lt; nums[0]</code>,最小值就在mid左边</li>
</ul>
</li>
<li><p>当我们找到这个中间点后，右边的元素如果比当前点小，那么mid + 1就是最小值，否则就是mid是最小值</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[right] &gt; nums[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[mid + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid - <span class="number">1</span>] &gt; nums[mid]) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[mid];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[<span class="number">0</span>]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h4 id="第三种写法（个人比较爱用这种）"><a href="#第三种写法（个人比较爱用这种）" class="headerlink" title="第三种写法（个人比较爱用这种）"></a>第三种写法（个人比较爱用这种）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left + <span class="number">1</span> &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (nums[left] == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[right] == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法主要用于搜索需要<em>访问当前索引及其在数组中的直接左右邻居索引</em>的元素或条件。</p>
<p><strong>特征</strong></p>
<ul>
<li>实现二分查找的另一种方法。</li>
<li>搜索条件需要访问元素的直接左右邻居。</li>
<li>使用元素的邻居来确定它是向右还是向左。</li>
<li>保证查找空间在每个步骤中至少有 3 个元素。</li>
<li>需要进行后处理。 当剩下 2 个元素时，循环 / 递归结束。 需要评估其余元素是否符合条件。</li>
</ul>
<blockquote>
<p>LeetCode162 - 寻找峰值</p>
</blockquote>
<p>这次利用第三种模板写一次</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left + <span class="number">1</span> &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[left] &gt;= nums[right]) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><blockquote>
<p><strong>LeetCode153</strong> - 寻找排序数组中得最小值</p>
</blockquote>
<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 <code>[0,1,2,4,5,6,7] </code>可能变为<code> [4,5,6,7,0,1,2]</code> )。</p>
<p>请找出其中最小的元素。</p>
<p>你可以假设数组中不存在重复元素。</p>
<p>示例1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,4,5,1,2]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p>示例2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [4,5,6,7,0,1,2]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left + <span class="number">1</span> &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[right]) &#123;</span><br><span class="line">                <span class="comment">//证明最小值在右边的线段上</span></span><br><span class="line">                left = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//left,right</span></span><br><span class="line">        <span class="keyword">if</span> (nums[left] &lt;= nums[right]) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[left];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[right];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>LeetCode154</strong> - 寻找旋转排序数组中的最小值 II</p>
</blockquote>
<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 <code>[0,1,2,4,5,6,7] </code>可能变为<code> [4,5,6,7,0,1,2]</code> )。</p>
<p>请找出其中最小的元素。</p>
<p>假设数组中存在重复元素。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,2,0,1]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left + <span class="number">1</span> &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[left] == nums[mid]) &#123;</span><br><span class="line">                <span class="comment">//去重</span></span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[right]) &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (nums[left] &lt;= nums[right]) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[left];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[right];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>LeetCode287</strong> - 寻找重复数</p>
</blockquote>
<p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,4,2,2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,1,3,4,2]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>不能更改原数组（假设数组是只读的）。</li>
<li>只能使用额外的 O(1) 的空间。</li>
<li>时间复杂度小于 O(n^2) 。</li>
<li>数组中只有一个重复的数字，但它可能不止重复出现一次。</li>
</ul>
<blockquote>
<p>解题思路</p>
</blockquote>
<p>这道题的思路是，虽然数组是无序的，但是数组内元素的大小是1~N排列的，因此从这种意义上看是有序的，可以用二分。但是二分的话不能用第三种模板的形式，第三种形式的推出循环的条件是left+1=right，无法确定最后重复的是left还是right。因此我打算用第二种形式的模板，也就是判断条件是left &lt; right：</p>
<ul>
<li>首先随机选中一个值mid</li>
<li>判断nums数组中有多少小于等于mid 的值，用count记录下来</li>
<li>如果count大于mid了，就证明left到mid这段区间内有重复的，否则就去mid到right这段区间去找,mid肯定不是重复的，(left = mid + 1)</li>
<li>最后left == right退出循环了，也就找到了最终的结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num &lt;= mid) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (count &lt;= mid) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/16/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%B3%95-%E4%B8%80/" data-id="ckhk6n3ti0000dslj05bgbbry" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ElasticSearch基本使用(一)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/14/ElasticSearch%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8(%E4%B8%80)/" class="article-date">
  <time datetime="2020-11-14T08:02:14.000Z" itemprop="datePublished">2020-11-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/14/ElasticSearch%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8(%E4%B8%80)/">ElasticSearch基本使用(一)：Get Started与复合查询</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>学习任意一种工具，我个人习惯是先看官方文档，因此学习ElasticSearch也是一样的，但是由于ES的中文版本比较低，所以我的学习主要借鉴的是官方英文文档中ES<code>7.10X</code>的版本，因此笔记中出现的某些列子也都是官方文档中标注的。该篇文章仅仅是对ES的使用做一些简要的介绍。</p>
<hr>
<ul>
<li><p><strong>Get Started</strong></p>
<ul>
<li><p>建立Index</p>
<ul>
<li><p>通过<code>PUT</code>请求特定的index</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUT /customer/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;YoungLH&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果customer这个Index库不存在的话，那么ES会自动帮助你创建这个Index，并且按照上面的命令会创建一条ID为1的document。</p>
</li>
</ul>
</li>
<li><p>搜索操作</p>
<p>在建立了Index之后我们就可以开始去搜索相应的Index内的document数据，这时候我们会利用<code>GET</code>请求，并配合相应的<code>_search</code>字段，而在请求内部就可以利用ES的查询DSL语言去构建查询条件</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /customer/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;query&quot;</span> : &#123;</span><br><span class="line">        match_all : &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;sort&quot; : [</span><br><span class="line">        &#123;<span class="attr">&quot;account_num&quot;</span> : <span class="string">&quot;asc&quot;</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查询之后返回的相应体内<code>hits</code>字段内就包含满足条件的数据。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;took&quot;</span> : <span class="number">63</span>,</span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : <span class="number">5</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span> : <span class="number">5</span>,</span><br><span class="line">    <span class="attr">&quot;skipped&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;hits&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;value&quot;</span>: <span class="number">1000</span>,</span><br><span class="line">        <span class="attr">&quot;relation&quot;</span>: <span class="string">&quot;eq&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;max_score&quot;</span> : <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">&quot;hits&quot;</span> : [ &#123;</span><br><span class="line">      <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;bank&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;0&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;sort&quot;</span>: [<span class="number">0</span>],</span><br><span class="line">      <span class="attr">&quot;_score&quot;</span> : <span class="literal">null</span>,</span><br><span class="line">      <span class="attr">&quot;_source&quot;</span> : &#123;<span class="attr">&quot;account_number&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;balance&quot;</span>:<span class="number">16623</span>,<span class="attr">&quot;firstname&quot;</span>:<span class="string">&quot;Bradshaw&quot;</span>,<span class="attr">&quot;lastname&quot;</span>:<span class="string">&quot;Mckenzie&quot;</span>,<span class="attr">&quot;age&quot;</span>:<span class="number">29</span>,<span class="attr">&quot;gender&quot;</span>:<span class="string">&quot;F&quot;</span>,<span class="attr">&quot;address&quot;</span>:<span class="string">&quot;244 Columbus Place&quot;</span>,<span class="attr">&quot;employer&quot;</span>:<span class="string">&quot;Euron&quot;</span>,<span class="attr">&quot;email&quot;</span>:<span class="string">&quot;bradshawmckenzie@euron.com&quot;</span>,<span class="attr">&quot;city&quot;</span>:<span class="string">&quot;Hobucken&quot;</span>,<span class="attr">&quot;state&quot;</span>:<span class="string">&quot;CO&quot;</span>&#125;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;bank&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;sort&quot;</span>: [<span class="number">1</span>],</span><br><span class="line">      <span class="attr">&quot;_score&quot;</span> : <span class="literal">null</span>,</span><br><span class="line">      <span class="attr">&quot;_source&quot;</span> : &#123;<span class="attr">&quot;account_number&quot;</span>:<span class="number">1</span>,<span class="attr">&quot;balance&quot;</span>:<span class="number">39225</span>,<span class="attr">&quot;firstname&quot;</span>:<span class="string">&quot;Amber&quot;</span>,<span class="attr">&quot;lastname&quot;</span>:<span class="string">&quot;Duke&quot;</span>,<span class="attr">&quot;age&quot;</span>:<span class="number">32</span>,<span class="attr">&quot;gender&quot;</span>:<span class="string">&quot;M&quot;</span>,<span class="attr">&quot;address&quot;</span>:<span class="string">&quot;880 Holmes Lane&quot;</span>,<span class="attr">&quot;employer&quot;</span>:<span class="string">&quot;Pyrami&quot;</span>,<span class="attr">&quot;email&quot;</span>:<span class="string">&quot;amberduke@pyrami.com&quot;</span>,<span class="attr">&quot;city&quot;</span>:<span class="string">&quot;Brogan&quot;</span>,<span class="attr">&quot;state&quot;</span>:<span class="string">&quot;IL&quot;</span>&#125;</span><br><span class="line">    &#125;, ...</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了<code>hits</code>字段外，其余的字段分别为：</p>
<ul>
<li><p><code>took</code>：这段查询花费了多长时间，单位为毫秒</p>
</li>
<li><p><code>time_out</code>：这段查询是不是超时了</p>
</li>
<li><p><code>_shards</code>：查询后有多少个分片成功、失败或者是被跳过</p>
</li>
<li><p><code>max_score</code>：最匹配的那条document数据的分数</p>
</li>
<li><p><code>hits.total.value</code>：有多少个document被找到</p>
</li>
<li><p><code>hits.sort</code>：对document的排序</p>
</li>
<li><p><code>hits._sort</code>：document的相关度分数（在使用<code>match_all</code>的时候是不起作用的）</p>
<p>如果说还想用分页查询，那么可以在请求体内加入<code>from</code>和<code>size字段</code></p>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123; <span class="attr">&quot;match_all&quot;</span>: &#123;&#125; &#125;,</span><br><span class="line">  <span class="attr">&quot;sort&quot;</span>: [</span><br><span class="line">    &#123; <span class="attr">&quot;account_number&quot;</span>: <span class="string">&quot;asc&quot;</span> &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;from&quot;</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">&quot;size&quot;</span>: <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进一步的，如果说想要构建更精准的查询，我们在请求体内就不会继续使用<code>match_all</code>这个字段了。</p>
<p>为了精确匹配某些字段，我们一般都使用<code>match</code>查询，例如在官方文档中的例子：比如我们要查询的是地址中包含mill或者lane的信息：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;query&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;match&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;address&quot;</span> : <span class="string">&quot;mill lane&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但如果我们要查询的是整个句子而不是单个的单词，我们可以试用<code>match_phrase</code>去匹配</p>
<p>此外，如果想进一步做复杂查询，我们就可以试用<code>bool</code>查询去包含多个查询条件，一般来说分成must match、should match、must not match</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;must&quot;</span>: [</span><br><span class="line">        &#123; <span class="attr">&quot;match&quot;</span>: &#123; <span class="attr">&quot;age&quot;</span>: <span class="string">&quot;40&quot;</span> &#125; &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;must_not&quot;</span>: [</span><br><span class="line">        &#123; <span class="attr">&quot;match&quot;</span>: &#123; <span class="attr">&quot;state&quot;</span>: <span class="string">&quot;ID&quot;</span> &#125; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样我们还可以对结果进行过滤</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;must&quot;</span>: &#123; <span class="attr">&quot;match_all&quot;</span>: &#123;&#125; &#125;,</span><br><span class="line">      <span class="attr">&quot;filter&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;range&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;balance&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;gte&quot;</span>: <span class="number">20000</span>,</span><br><span class="line">            <span class="attr">&quot;lte&quot;</span>: <span class="number">30000</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p><strong>查询DSL语句</strong></p>
<p>在完成了前面的Get Started之后，我们来看一下官方文档中给出的具体的DSL语句。</p>
<p>官方文档中给出ES有两种基本的查询：一种是叶子查询子句，另一种是复合查询子句，叶子查询子句是在特定字段中查找特定值，例如使用<code>match</code>，<code>term</code>，<code>range</code>查询。而复合查询子句可以包含其它的叶子查询语句或者复合查询语句，然后将它们用一定的逻辑组合起来，比如使用<code>bool</code>查询或者<code>dis_max</code>查询。具体查询子句做了什么是依据这些子句是在查询上下文中还是说在过滤器上下文中。</p>
<p>那什么是查询上下文和过滤器上下文呢？</p>
<p>首先我们要介绍几个概念：</p>
<ul>
<li><p>相关度分值</p>
<p>默认情况下ES对于匹配到的搜索结果进行排序都是依照相关度分值进行的，它体现的是每条document数据和这条查询中匹配的程度。这个分值会存储在<code>_score</code>这个字段中进行返回。同时这个分值的计算归根到底也是依据我们的查询语句是在查询上下文中还是过滤器上下文中。</p>
</li>
<li><p>查询上下文</p>
<p>在查询上下文中，查询子句回答以下问题：“此文档与该查询子句的匹配程度如何？” 除了确定文档是否匹配之外，查询子句还计算<code>_score</code>元数据字段中的相关性得分。</p>
<p>只要将查询子句传递到查询参数（例如搜索API中的查询参数），查询上下文就有效。</p>
</li>
<li><p>过滤器上下文</p>
<p>在过滤器上下文中，查询子句回答问题“此文档与该查询子句匹配吗？” 答案是简单的“是”或“否”，即不计算分数。 过滤器上下文主要用于过滤结构化数据，例如</p>
<p>此时间戳记是否在2015年至2016年的范围内？<br>状态字段设置为“已发布”吗？<br>常用的过滤器将由ElasticSearch自动缓存，以提高性能。</p>
<p>每当将查询子句传递到过滤器参数（例如bool查询中的filter或must_not参数，constant_score查询中的filter参数或过滤器聚合）时，过滤器上下文即生效。</p>
</li>
<li><p>例子</p>
<p>下面我们来看一下官方文档中的例子：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123; <span class="comment">//1</span></span><br><span class="line">    <span class="attr">&quot;bool&quot;</span>: &#123; <span class="comment">//2</span></span><br><span class="line">      <span class="attr">&quot;must&quot;</span>: [</span><br><span class="line">        &#123; <span class="attr">&quot;match&quot;</span>: &#123; <span class="attr">&quot;title&quot;</span>:   <span class="string">&quot;Search&quot;</span>        &#125;&#125;,</span><br><span class="line">        &#123; <span class="attr">&quot;match&quot;</span>: &#123; <span class="attr">&quot;content&quot;</span>: <span class="string">&quot;Elasticsearch&quot;</span> &#125;&#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;filter&quot;</span>: [<span class="comment">//3 </span></span><br><span class="line">        &#123; <span class="attr">&quot;term&quot;</span>:  </span><br><span class="line">         &#123; <span class="attr">&quot;status&quot;</span>: <span class="string">&quot;published&quot;</span> </span><br><span class="line">         &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123; <span class="attr">&quot;range&quot;</span>: </span><br><span class="line">         &#123; <span class="attr">&quot;publish_date&quot;</span>: </span><br><span class="line">          &#123; <span class="attr">&quot;gte&quot;</span>: <span class="string">&quot;2015-01-01&quot;</span> &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li> <code>query</code>字段表示是查询上下文。</li>
<li> <code>bool</code>和两个<code>match</code>字段是在<code>query</code>字段内使用的，因此这就意味着他们搜索的结果会被计算相关度分值。</li>
<li> <code>filter</code>字段说明是过滤器上下文，在上面的例子中里面包含了<code>term</code>和<code>range</code>字段，他们就会过滤出那些符合条件的document数据，但是并不会影响上面计算的相关度分值。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>复合查询</p>
<p>复合查询一般包括以下几种：</p>
<ul>
<li><p><code>bool</code>查询</p>
<p>默认查询，用于组合多个叶子或复合查询子句（<code>must</code>，<code>should</code>，<code>must_not</code>或<code>filter</code>子句）。 must和should子句的分数组合在一起-匹配的子句越多越好-而must_not和filter子句在过滤器上下文中执行。</p>
</li>
<li><p><code>boosting</code>查询</p>
<p>返回与正查询匹配的文档，但减少也与负查询匹配的文档的分数。</p>
</li>
<li><p><code>constant_score</code>查询</p>
<p>它包装另一个查询，但在过滤器上下文中执行它。所有匹配的文档都使用相同的常数_score。</p>
</li>
<li><p><code>dis_max</code>查询</p>
<p>它接受多个查询，并返回与任何查询子句匹配的任何文档。当布尔查询合并所有匹配查询的分数时，dis_max查询使用单个最佳匹配查询子句的分数。</p>
</li>
<li><p><code>function_score</code>查询</p>
<p>这个是使用自己定义的算法进行查询。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><code>bool</code>查询</p>
<p><code>bool</code>查询中主要包含下面几种字段：</p>
<ul>
<li><p><code>must</code></p>
<p>查询子句必须包含的字段。</p>
</li>
<li><p><code>filter</code></p>
<p>这个字段负责过滤，但不会参与到相关度分值的计算。</p>
</li>
<li><p><code>should</code></p>
<p>或的逻辑。</p>
</li>
<li><p><code>must_not</code></p>
<p>指定不能出现在查询结果中的字段。</p>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">POST _search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;bool&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;must&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;term&quot;</span> : &#123; <span class="attr">&quot;user.id&quot;</span> : <span class="string">&quot;kimchy&quot;</span> &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;filter&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;term&quot;</span> : &#123; <span class="attr">&quot;tags&quot;</span> : <span class="string">&quot;production&quot;</span> &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;must_not&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;range&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;age&quot;</span> : &#123; <span class="attr">&quot;gte&quot;</span> : <span class="number">10</span>, <span class="attr">&quot;lte&quot;</span> : <span class="number">20</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;should&quot;</span> : [</span><br><span class="line">        &#123; <span class="attr">&quot;term&quot;</span> : &#123; <span class="attr">&quot;tags&quot;</span> : <span class="string">&quot;env1&quot;</span> &#125; &#125;,</span><br><span class="line">        &#123; <span class="attr">&quot;term&quot;</span> : &#123; <span class="attr">&quot;tags&quot;</span> : <span class="string">&quot;deployed&quot;</span> &#125; &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;minimum_should_match&quot;</span> : <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;boost&quot;</span> : <span class="number">1.0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>给<code>bool.filter</code>分配score</p>
<p>首先，我们从前文可以看到，分布在<code>filter</code>标签下的查询语句对于score是没有影响的，也就是说在过滤器上下文下的查询语句返回的相关度分值是0。只有查询语句在精确匹配的前提下才会有score。</p>
</li>
<li><p><code>named</code>查询</p>
<p>每个查询都接收一个<code>_name</code>字段，我们可以使用<code>named</code>查询去跟踪哪些查询与返回的结果文档匹配。如果使用了<code>named</code>查询，那么在返回的响应中每一个命中的document都会包含<code>matched_queries</code>这个属性字段。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;should&quot;</span>: [</span><br><span class="line">        &#123; <span class="attr">&quot;match&quot;</span>: &#123; <span class="attr">&quot;name.first&quot;</span>: &#123; <span class="attr">&quot;query&quot;</span>: <span class="string">&quot;shay&quot;</span>, <span class="attr">&quot;_name&quot;</span>: <span class="string">&quot;first&quot;</span> &#125; &#125; &#125;,</span><br><span class="line">        &#123; <span class="attr">&quot;match&quot;</span>: &#123; <span class="attr">&quot;name.last&quot;</span>: &#123; <span class="attr">&quot;query&quot;</span>: <span class="string">&quot;banon&quot;</span>, <span class="attr">&quot;_name&quot;</span>: <span class="string">&quot;last&quot;</span> &#125; &#125; &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;filter&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;terms&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;name.last&quot;</span>: [ <span class="string">&quot;banon&quot;</span>, <span class="string">&quot;kimchy&quot;</span> ],</span><br><span class="line">          <span class="attr">&quot;_name&quot;</span>: <span class="string">&quot;test&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>boosting</code>查询</p>
<p><code>boosting</code>查询会返回匹配了<code>positive</code>查询字段的那些document，然而如果这条查询也匹配到了<code>negative</code>查询，返回的结果就会减低document的相关度分数。</p>
<p>应用场景：我们可以使用<code>boosting</code>查询去对某些查询结果进行降级，而不是说从搜索结果中将其剔除。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;boosting&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;positive&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;term&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;apple&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;negative&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;term&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;pie tart fruit crumble tree&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;negative_boost&quot;</span>: <span class="number">0.5</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那问题就是怎么降级？官方文档中给出了相应的解释：</p>
<p>在<code>negative</code>字段下面还有一个<code>negative_boost</code>字段，我们可以指定这个字段的value值，比如上面例子的0.5。那么具体的降级计算过程就是：</p>
<ul>
<li>首先拿到初始的<code>positive</code>查询的相关度分数</li>
<li>将上面的分数乘以<code>negative_boost</code>的值，就是降级后的结果。<ul>
<li>注意：<code>negative_boost</code>字段的值一般是浮点数，从0到1.0之间</li>
</ul>
</li>
</ul>
</li>
<li><p><code>constant score</code>查询</p>
<p>包装过滤查询，并返回相关度分数等于boost参数值的每个匹配文档。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;constant_score&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;filter&quot;</span>: &#123;<span class="comment">//过滤后的结果会被缓存</span></span><br><span class="line">        <span class="attr">&quot;term&quot;</span>: &#123; <span class="attr">&quot;user.id&quot;</span>: <span class="string">&quot;kimchy&quot;</span> &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;boost&quot;</span>: <span class="number">1.2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>disjunction max</code>查询</p>
<p>它接受多个查询，并返回与任何查询子句匹配的任何文档。当布尔查询合并所有匹配查询的分数时，dis_max查询使用单个最佳匹配查询子句的分数。</p>
<p>我们可以使用<code>dis_max</code>字段在不同的boost因子映射的字段中去搜索</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;dis_max&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;queries&quot;</span>: [</span><br><span class="line">        &#123; <span class="attr">&quot;term&quot;</span>: &#123; <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;Quick pets&quot;</span> &#125; &#125;,</span><br><span class="line">        &#123; <span class="attr">&quot;term&quot;</span>: &#123; <span class="attr">&quot;body&quot;</span>: <span class="string">&quot;Quick pets&quot;</span> &#125; &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;tie_breaker&quot;</span>: <span class="number">0.7</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>queries</code></p>
<p>这个字段包含一个或者多个查询子句，同样返回的字段中也必须匹配一个或者多个查询。如果一个文档匹配了多个查询，那么ES会返回的是最高的相关度分数。</p>
</li>
<li><p><code>tie_breaker</code></p>
<p>这是一个可选字段，是一个0到1.0之间的浮点数。我们可以通过给多个字段中包含相同术语的文档分配更好的包含该术语的相关度分数，从而避免混淆。</p>
<p>具体的计算流程：</p>
<ul>
<li>首先拿到匹配子句的最高相关度分值</li>
<li>将上述结果乘以我们设置的<code>tie_breaker</code>值</li>
<li>将最高的分值加到我们第二步的分值上去</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>参考文献</strong><ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-bool-query.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-bool-query.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-boosting-query.html#boosting-query-ex-request">https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-boosting-query.html#boosting-query-ex-request</a></li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-constant-score-query.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-constant-score-query.html</a></li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/14/ElasticSearch%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8(%E4%B8%80)/" data-id="ckhw4sfem0000vslj72g21pay" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/12/31/MIT6-824%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9FLab1-MapReduce/">MIT6.824分布式系统Lab1-MapReduce</a>
          </li>
        
          <li>
            <a href="/2020/12/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97-%E5%A0%86/">数据结构(优先级队列/堆)</a>
          </li>
        
          <li>
            <a href="/2020/12/09/Elasticsearch%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%B9%E6%80%A7/">Elasticsearch分布式特性</a>
          </li>
        
          <li>
            <a href="/2020/11/24/ElasticSearch%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%8E%9F%E7%90%86/">ElasticSearch基本概念与原理</a>
          </li>
        
          <li>
            <a href="/2020/11/16/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%B3%95-%E4%B8%80/">算法-二分法(一)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 Larry Young<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>